1
00:00:00,000 --> 00:00:00,080


2
00:00:00,080 --> 00:00:02,430
 Konten berikut disediakan di bawah Materi Iklan 

3
00:00:02,430 --> 00:00:03,820
 Lisensi Commons. 

4
00:00:03,820 --> 00:00:06,060
 Dukungan Anda akan membantu MIT OpenCourseWare 

5
00:00:06,060 --> 00:00:10,150
 terus menawarkan sumber daya pendidikan berkualitas tinggi secara gratis. 

6
00:00:10,150 --> 00:00:12,690
 Untuk membuat sumbangan, atau untuk melihat materi tambahan 

7
00:00:12,690 --> 00:00:16,600
 dari ratusan kursus MIT, kunjungi MIT OpenCourseWare 

8
00:00:16,600 --> 00:00:17,310
 di ocw.mit.edu. 

9
00:00:17,310 --> 00:00:25,998


10
00:00:25,998 --> 00:00:27,780
 PROFESOR: Baiklah, mari kita mulai. 

11
00:00:27,780 --> 00:00:33,090
 Jadi selamat datang di kuliah berikutnya tentang mengeksploitasi 

12
00:00:33,090 --> 00:00:33,921
 buffer overflow. 

13
00:00:33,921 --> 00:00:35,420
 Jadi hari ini, apa yang akan kita lakukan adalah, 

14
00:00:35,420 --> 00:00:38,810
 kita akan menyelesaikan diskusi kita tentang batas longgar 

15
00:00:38,810 --> 00:00:40,990
 dan kemudian kita akan beralih ke pasangan 

16
00:00:40,990 --> 00:00:44,400
 teknik lain yang berbeda untuk melindungi buffernya 

17
00:00:44,400 --> 00:00:45,180
 overflows. 

18
00:00:45,180 --> 00:00:48,020
 Kemudian kita akan berbicara tentang kertas untuk hari ini, 

19
00:00:48,020 --> 00:00:51,032
 yang merupakan blind oriented oriented programming. 

20
00:00:51,032 --> 00:00:53,240
 Jadi jika Anda seperti saya ketika Anda pertama kali membaca koran itu 

21
00:00:53,240 --> 00:00:55,780
 Anda merasa seperti sedang menonton seperti seorang Christopher 

22
00:00:55,780 --> 00:00:56,665
 Nolan film di awal. 

23
00:00:56,665 --> 00:00:58,350
 Itu seperti pikiran bertiup tepat. 

24
00:00:58,350 --> 00:00:59,030
 Jadi apa yang akan kita lakukan adalah kita 

25
00:00:59,030 --> 00:01:01,363
 akan benar-benar melangkah melalui bagaimana beberapa gadget ini 

26
00:01:01,363 --> 00:01:02,090
 bekerja dengan benar. 

27
00:01:02,090 --> 00:01:03,548
 Dan semoga pada akhirnya, Anda akan 

28
00:01:03,548 --> 00:01:05,995
 dapat memahami semua ini semacam keragu-raguan teknologi tinggi 

29
00:01:05,995 --> 00:01:08,110
 yang mereka lakukan di koran. 

30
00:01:08,110 --> 00:01:09,810
 Jadi pertama-tama, seperti saya katakan, mari 

31
00:01:09,810 --> 00:01:13,210
 tutup saja dengan diskusi batas longgar. 

32
00:01:13,210 --> 00:01:18,480
 Mari kita telusuri contoh yang sangat sederhana di sini. 

33
00:01:18,480 --> 00:01:26,280
 Jadi mari kita katakan bahwa kita akan mendefinisikan pointer yang disebut P. 

34
00:01:26,280 --> 00:01:28,400
 Dan katakanlah kita akan memberikannya 

35
00:01:28,400 --> 00:01:30,360
 ukuran alokasi 44. 

36
00:01:30,360 --> 00:01:37,960
 Mari kita berasumsi bahwa ukuran slot sama dengan 16 byte OK. 

37
00:01:37,960 --> 00:01:40,630
 Jadi apa yang akan terjadi ketika kita melakukan malloc ini di sini? 

38
00:01:40,630 --> 00:01:42,460
 Jadi seperti yang Anda tahu, sistem batas longgar 

39
00:01:42,460 --> 00:01:46,401
 akan pad alokasi yang keluar ke kekuatan dua berikutnya, 

40
00:01:46,401 --> 00:01:46,900
 kanan. 

41
00:01:46,900 --> 00:01:49,730
 Jadi meskipun kami hanya mengalokasikan 44 byte di sini, 

42
00:01:49,730 --> 00:01:54,130
 kita benar-benar akan mengalokasikan 64 byte untuk pointer ini 

43
00:01:54,130 --> 00:01:56,470
 di sini. 

44
00:01:56,470 --> 00:01:59,671
 Dan begitu juga perhatikan juga, ini adalah ukuran slot 16. 

45
00:01:59,671 --> 00:02:01,920
 Berapa banyak entri tabel batas yang akan kita buat? 

46
00:02:01,920 --> 00:02:04,960
 Kita akan membuat ukuran alokasi, yang 

47
00:02:04,960 --> 00:02:08,970
 dalam hal ini 64, dibagi dengan ukuran slot, yaitu 16. 

48
00:02:08,970 --> 00:02:12,280
 Jadi dalam hal ini kita akan membuat empat tabel batas yang berbeda 

49
00:02:12,280 --> 00:02:14,554
 entri untuk hal ini di sini. 

50
00:02:14,554 --> 00:02:15,970
 Masing-masing dari entri tersebut akan hadir 

51
00:02:15,970 --> 00:02:18,631
 harus diatur ke log ukuran alokasi, yang 

52
00:02:18,631 --> 00:02:20,130
 dalam hal ini akan menjadi 6 benar. 

53
00:02:20,130 --> 00:02:22,800
 Karena ukuran alokasi adalah 64, oke? 

54
00:02:22,800 --> 00:02:24,070
 Jadi, sejauh ini sangat bagus. 

55
00:02:24,070 --> 00:02:31,180
 Kemudian kita akan mendefinisikan pointer lain yang disebut q 

56
00:02:31,180 --> 00:02:36,770
 dan kita akan mengaturnya sama dengan p plus 60. 

57
00:02:36,770 --> 00:02:38,350
 Jadi apa yang terjadi ketika kita melakukan ini? 

58
00:02:38,350 --> 00:02:40,350
 Perhatikan bahwa dengan tegas berbicara, 

59
00:02:40,350 --> 00:02:43,070
 akses ini di luar batas, benar. 

60
00:02:43,070 --> 00:02:45,470
 Karena ini hanya mengalokasikan 44 byte memori, 

61
00:02:45,470 --> 00:02:47,345
 tapi tentu saja cara batas longgar itu berhasil 

62
00:02:47,345 --> 00:02:50,300
 adalah bahwa itu benar-benar akan memungkinkan axis yang berada di luar batas, 

63
00:02:50,300 --> 00:02:52,290
 jika mereka tetap dalam batas longgar itu. 

64
00:02:52,290 --> 00:02:53,879
 Jadi meski berbicara ketat, 

65
00:02:53,879 --> 00:02:55,920
 programmer seharusnya tidak melakukan ini, 

66
00:02:55,920 --> 00:02:57,720
 ini sebenarnya akan baik-baik saja, benar. 

67
00:02:57,720 --> 00:03:01,170
 Kami tidak akan menaikkan bendera atau apapun seperti itu. 

68
00:03:01,170 --> 00:03:04,230
 Sekarang katakanlah hal berikutnya yang kita lakukan 

69
00:03:04,230 --> 00:03:09,430
 adalah kita perlu mencari pointer lain, yang akan menjadi 

70
00:03:09,430 --> 00:03:14,340
 set sama dengan q plus 16 tepat. 

71
00:03:14,340 --> 00:03:21,290
 Sekarang ini sebenarnya akan menyebabkan kesalahan, benar. 

72
00:03:21,290 --> 00:03:31,660
 Karena sekarang q berada pada offset 60 ditambah 16, yang sama dengan 76. 

73
00:03:31,660 --> 00:03:34,720
 Jadi ini sebenarnya 12 byte jauh dari akhir 

74
00:03:34,720 --> 00:03:36,380
 dari batas longgar itu. 

75
00:03:36,380 --> 00:03:36,980
 BAIK? 

76
00:03:36,980 --> 00:03:39,964
 Dan itu sebenarnya lebih dari setengah slot. 

77
00:03:39,964 --> 00:03:42,380
 Baiklah, jadi jika Anda ingat sistem batas longgar akan 

78
00:03:42,380 --> 00:03:44,690
 sebenarnya melemparkan kesalahan sinkron keras jika Anda 

79
00:03:44,690 --> 00:03:47,630
 melampaui 1/2 slot dari tepi batas longgar itu. 

80
00:03:47,630 --> 00:03:49,630
 Jadi ini benar-benar akan menyebabkan program gagal. 

81
00:03:49,630 --> 00:03:51,210
 Ini benar-benar akan membuatnya berhenti. 

82
00:03:51,210 --> 00:03:54,020
 Sekarang mari kita bayangkan bahwa kita tidak memiliki baris kode ini 

83
00:03:54,020 --> 00:03:55,140
 di dalam program, oke. 

84
00:03:55,140 --> 00:03:57,610
 Jadi kami punya dua ini, tapi kami tidak punya yang ini. 

85
00:03:57,610 --> 00:04:00,290
 Jadi bagaimana jika kita bukannya melakukan baris ini, 

86
00:04:00,290 --> 00:04:02,230
 melakukan sesuatu yang terlihat seperti ini. 

87
00:04:02,230 --> 00:04:06,790
 Kami menyatakan penunjuk lain, sebut saja s, 

88
00:04:06,790 --> 00:04:11,700
 dan kami mengaturnya sama dengan q plus 8. 

89
00:04:11,700 --> 00:04:14,580
 Sekarang dalam hal ini, penunjuk akan berjalan 

90
00:04:14,580 --> 00:04:22,480
 berada di 60 plus 8, yang sama dengan 68 byte jauh dari p, benar. 

91
00:04:22,480 --> 00:04:25,680
 Jadi ini hanya empat byte di luar batas yang longgar itu. 

92
00:04:25,680 --> 00:04:28,280
 Jadi ini tidak akan benar-benar menyebabkan kesalahan. 

93
00:04:28,280 --> 00:04:30,740
 Meskipun itu benar-benar berbicara, di luar batas. 

94
00:04:30,740 --> 00:04:33,060
 Apa yang akan kita lakukan di sini adalah mengatur urutan tinggi 

95
00:04:33,060 --> 00:04:34,950
 sedikit pada penunjuk, kan. 

96
00:04:34,950 --> 00:04:36,610
 Sehingga jika ada yang mencoba 

97
00:04:36,610 --> 00:04:38,390
 untuk dereference hal ini, itu akan terjadi 

98
00:04:38,390 --> 00:04:41,770
 menyebabkan kesalahan yang keras pada saat itu. 

99
00:04:41,770 --> 00:04:44,350
 Dan kemudian katakanlah, hal terakhir yang kita lakukan 

100
00:04:44,350 --> 00:04:51,250
 adalah kita menyatakan t pointer lain, yang 

101
00:04:51,250 --> 00:04:56,599
 akan sama dengan minus 32. 

102
00:04:56,599 --> 00:04:58,390
 Jadi yang terjadi di sini adalah pada dasarnya kita 

103
00:04:58,390 --> 00:05:02,280
 membawa pointer ini, sekarang kembali dalam batas, benar. 

104
00:05:02,280 --> 00:05:06,510
 Jadi apa artinya itu meskipun orang ini keluar 

105
00:05:06,510 --> 00:05:09,210
 batas, sekarang kita semacam kembali ke yang asli dialokasikan 

106
00:05:09,210 --> 00:05:11,290
 wilayah, yang awalnya kami buat di sini. 

107
00:05:11,290 --> 00:05:14,946
 Jadi sebagai hasilnya, t tidak akan memiliki langkah bit tingkat tinggi 

108
00:05:14,946 --> 00:05:17,320
 sehingga Anda dapat dereference T dan semuanya akan baik-baik saja. 

109
00:05:17,320 --> 00:05:18,490
 Jadi ini semua masuk akal? 

110
00:05:18,490 --> 00:05:20,073
 Ini seharusnya cukup mudah. 

111
00:05:20,073 --> 00:05:22,207
 AUDIENCE: [TIDAK JELAS] perbedaannya 

112
00:05:22,207 --> 00:05:25,920
 antara r dan s, bagaimana Anda tahu bahwa r adalah ... 

113
00:05:25,920 --> 00:05:31,365
 atau bagaimana program mengetahui bahwa r adalah 1/2 [TIDAK JELAS]. 

114
00:05:31,365 --> 00:05:34,830
 PROFESOR: Jadi perhatikan bahwa, seperti di sini, 

115
00:05:34,830 --> 00:05:39,308
 ketika kita membuat r Anda pada dasarnya dapat menempatkan, 

116
00:05:39,308 --> 00:05:40,861
 kami mendapatkan kode yang diinstrumentasi 

117
00:05:40,861 --> 00:05:44,570
 akan bekerja di semua operasi penunjuk ini. 

118
00:05:44,570 --> 00:05:48,528
 Jadi pada dasarnya kita dapat mengatakan bahwa kita tahu di mana P akan terjadi. 

119
00:05:48,528 --> 00:05:51,276
 Maaf, kami tahu di mana q akan terjadi. 

120
00:05:51,276 --> 00:05:57,935
 Dan kita tahu bahwa q ada dalam batas-batas longgar itu. 

121
00:05:57,935 --> 00:05:59,907
 Jadi ketika kami melakukan operasi ini di sini, 

122
00:05:59,907 --> 00:06:01,890
 instrumentasi batas longgar 

123
00:06:01,890 --> 00:06:03,528
 tambahkan dan kami bisa mengatakan, aha, baik saya 

124
00:06:03,528 --> 00:06:05,444
 tahu darimana asal formula itu berasal. 

125
00:06:05,444 --> 00:06:07,760
 Dan kemudian jika Anda melihat offset ini di sini, 

126
00:06:07,760 --> 00:06:11,273
 Anda dapat menentukan lebih dari 1/2 slot dari sisi slot. 

127
00:06:11,273 --> 00:06:12,772
 Jadi pada dasarnya apa yang Anda pikirkan adalah 

128
00:06:12,772 --> 00:06:14,117
 bahwa saat kami melakukan operasi penunjuk ini, 

129
00:06:14,117 --> 00:06:16,317
 dan mencari dan berkata adalah bagaimana Anda keluar dari batas, 

130
00:06:16,317 --> 00:06:18,029
 apakah Anda sudah keluar batas, ya atau tidak. 

131
00:06:18,029 --> 00:06:20,362
 Pada titik tertentu Anda akan memiliki beberapa operasi 

132
00:06:20,362 --> 00:06:23,342
 akan melibatkan pointer yang baik dalam batas 

133
00:06:23,342 --> 00:06:25,758
 dalam batas longgar dan kemudian beberapa hal di sini itu 

134
00:06:25,758 --> 00:06:27,398
 membuatnya keluar dari batas. 

135
00:06:27,398 --> 00:06:29,366
 Jadi pada saat itu, tepat ketika itu terjadi, 

136
00:06:29,366 --> 00:06:30,760
 itulah bagaimana kita tahu bahwa ada sesuatu yang aneh 

137
00:06:30,760 --> 00:06:31,260
 muncul. 

138
00:06:31,260 --> 00:06:36,760


139
00:06:36,760 --> 00:06:39,420
 Baiklah, semoga itu semua masuk akal. 

140
00:06:39,420 --> 00:06:41,480
 Dan ini adalah ulasan yang sangat singkat 

141
00:06:41,480 --> 00:06:44,311
 pertanyaan pekerjaan rumah. 

142
00:06:44,311 --> 00:06:46,894
 Jadi semoga Anda bisa memahami ini dan pertanyaan pekerjaan rumah kami 

143
00:06:46,894 --> 00:06:48,394
 seharusnya cukup mudah dimengerti. 

144
00:06:48,394 --> 00:06:56,740
 Jadi kita memiliki pointer karakter malloc memiliki 256 byte untuk itu, 

145
00:06:56,740 --> 00:06:59,427
 Kemudian kami menyatakan penunjuk karakter 

146
00:06:59,427 --> 00:07:06,420
 q, itu sama dengan pointer itu ditambah 256 

147
00:07:06,420 --> 00:07:11,340
 dan kemudian kita pada dasarnya mencoba untuk mengalihkan pointer ini. 

148
00:07:11,340 --> 00:07:12,670
 Jadi apa yang akan terjadi? 

149
00:07:12,670 --> 00:07:15,870
 Nah perhatikan bahwa ini adalah kekuatan yang tepat juga, kan. 

150
00:07:15,870 --> 00:07:18,790
 Jadi sebenarnya tidak ada batasan dalam batas, benar. 

151
00:07:18,790 --> 00:07:23,430
 Jadi ketika kita melakukan ini di sini, ini membuat q menunjuk ke satu 

152
00:07:23,430 --> 00:07:26,070
 lulus akhir dari batas-batas longgar itu. 

153
00:07:26,070 --> 00:07:27,660
 Jadi seperti dalam contoh ini di sini, 

154
00:07:27,660 --> 00:07:30,930
 baris ini sebenarnya baik-baik saja, tetapi itu akan menyebabkan bit yang tinggi 

155
00:07:30,930 --> 00:07:32,217
 diatur dalam q, benar. 

156
00:07:32,217 --> 00:07:34,050
 Jadi ketika Anda datang ke sini dan referensi itu, 

157
00:07:34,050 --> 00:07:35,775
 maka semuanya meledak dan itu 

158
00:07:35,775 --> 00:07:37,670
 waktu untuk memanggil agen asuransi Anda. 

159
00:07:37,670 --> 00:07:40,420
 Jadi cukup mudah? 

160
00:07:40,420 --> 00:07:44,390
 OK jadi, itu pada dasarnya dua contoh 

161
00:07:44,390 --> 00:07:46,790
 bahwa Anda dapat membumbui untuk bagaimana batas baggy bekerja. 

162
00:07:46,790 --> 00:07:49,465
 Seperti yang saya sebutkan di kuliah terakhir, 

163
00:07:49,465 --> 00:07:51,590
 Anda sebenarnya tidak perlu instrumen setiap pointer 

164
00:07:51,590 --> 00:07:55,860
 operasi, jika Anda dapat menggunakan analisis kode statis untuk mencari tahu 

165
00:07:55,860 --> 00:07:58,250
 set operasi penunjuk tertentu aman. 

166
00:07:58,250 --> 00:07:59,900
 Saya akan menunda diskusi lebih lanjut tentang beberapa 

167
00:07:59,900 --> 00:08:01,600
 analisis statis [tidak terdengar], 

168
00:08:01,600 --> 00:08:04,133
 tetapi cukuplah untuk mengatakan bahwa Anda tidak selalu melakukannya 

169
00:08:04,133 --> 00:08:08,657
 harus memiliki semua aritmatika ini sedikit bijaksana yang Anda 

170
00:08:08,657 --> 00:08:12,086
 ada dalam beberapa kasus yang telah kami periksa sebelumnya. 

171
00:08:12,086 --> 00:08:15,870


172
00:08:15,870 --> 00:08:19,272
 Dan pertanyaan lain yang muncul di Piazza 

173
00:08:19,272 --> 00:08:21,230
 adalah, bagaimana batas baggy memastikan kompatibilitas 

174
00:08:21,230 --> 00:08:24,830
 dengan perpustakaan-perpustakaan yang sudah ada sebelumnya dan tidak terdokumentasi ini, 

175
00:08:24,830 --> 00:08:26,510
 kanan. 

176
00:08:26,510 --> 00:08:29,360
 Dan ide Piazza di belakang bagaimana batas baggy melakukan itu 

177
00:08:29,360 --> 00:08:33,200
 adalah, bahwa ketika batas longgar menginisialisasi tabel batas, 

178
00:08:33,200 --> 00:08:36,477
 mereka mengatur semua entri menjadi batas 31 itu. 

179
00:08:36,477 --> 00:08:37,938
 Jadi ketika kita membaca tabel batas, 

180
00:08:37,938 --> 00:08:40,510
 setiap entri mewakili 2 untuk kekuatan 

181
00:08:40,510 --> 00:08:43,899
 dari entri itu, ukuran penunjuk tertentu. 

182
00:08:43,899 --> 00:08:45,739
 Jadi dengan menginisialisasi semua batasan itu 

183
00:08:45,739 --> 00:08:49,692
 dari 31, apa yang memungkinkan kami lakukan adalah secara otomatis 

184
00:08:49,692 --> 00:08:52,670
 asumsikan bahwa setiap penunjuk dari [INAUDIBLE] kode 

185
00:08:52,670 --> 00:08:54,670
 akan memiliki batas terbesar, 2 

186
00:08:54,670 --> 00:08:56,259
 diangkat ke 31. 

187
00:08:56,259 --> 00:08:58,812
 Jadi biarkan saya memberi Anda contoh yang sangat sederhana di sini 

188
00:08:58,812 --> 00:09:00,770
 yang mudah-mudahan akan membuat ini sedikit lebih jelas. 

189
00:09:00,770 --> 00:09:05,060
 Jadi katakanlah ini di sini adalah ingatan 

190
00:09:05,060 --> 00:09:09,370
 ruang yang kita kehilangan untuk heap. 

191
00:09:09,370 --> 00:09:12,220


192
00:09:12,220 --> 00:09:15,860
 Ini contoh sederhana, mari kita anggap itu pada dasarnya 

193
00:09:15,860 --> 00:09:18,785
 apa ruang memori ini [tidak terdengar] dua komponen. 

194
00:09:18,785 --> 00:09:26,430
 Ini adalah tumpukan, yang keluar dengan kode tidak terdokumentasi. 

195
00:09:26,430 --> 00:09:31,042


196
00:09:31,042 --> 00:09:33,153
 Dan kemudian anggap itu di sini kita 

197
00:09:33,153 --> 00:09:40,563
 memiliki panas yang dialokasikan oleh kode yang diinstrumentasi. 

198
00:09:40,563 --> 00:09:44,892


199
00:09:44,892 --> 00:09:46,816
 Jadi apa batas baggy yang akan dilakukan? 

200
00:09:46,816 --> 00:09:51,041
 Jadi ingat, batas longgar memiliki gagasan ukuran slot ini, 

201
00:09:51,041 --> 00:09:51,540
 kanan. 

202
00:09:51,540 --> 00:09:53,467
 Jadi pada dasarnya ukuran slot adalah 16, 

203
00:09:53,467 --> 00:09:55,420
 Anda hanya memiliki entri untuk setiap jenis 

204
00:09:55,420 --> 00:09:57,619
 slot ukuran 16 di sini. 

205
00:09:57,619 --> 00:09:59,410
 Jadi pada dasarnya tabel batas dalam hal ini, 

206
00:09:59,410 --> 00:10:03,910
 Anda bisa memikirkan untuk diatur menjadi tiga 

207
00:10:03,910 --> 00:10:06,080
 tempat, maaf dua tempat. 

208
00:10:06,080 --> 00:10:12,190
 Jadi awalnya semua tabel batas, semua entri 

209
00:10:12,190 --> 00:10:16,160
 diinisialisasi ke 2 ke 30-- atau maaf, ke 31. 

210
00:10:16,160 --> 00:10:19,600
 Tapi kemudian akhirnya sebagai kode instrumen 

211
00:10:19,600 --> 00:10:23,740
 berjalan itu benar-benar akan menggunakan batas longgar 

212
00:10:23,740 --> 00:10:28,960
 algoritma untuk mengatur nilai-nilai ini untuk apa pun 

213
00:10:28,960 --> 00:10:33,711
 harus sesuai untuk itu [TIDAK JELAS], benar. 

214
00:10:33,711 --> 00:10:35,252
 Jadi apa yang terjadi akhirnya adalah jika Anda 

215
00:10:35,252 --> 00:10:39,608
 did-- jika kode yang diinstrumentasi mendapat pointer yang berasal dari sini, 

216
00:10:39,608 --> 00:10:42,010
 maka batas-batas longgar dengan setiap pointer tertentu 

217
00:10:42,010 --> 00:10:45,110
 akan selalu disetel ke nilai terbesar, 231. 

218
00:10:45,110 --> 00:10:45,945
 2 ke 31, benar. 

219
00:10:45,945 --> 00:10:47,320
 Artinya itu akan terjadi 

220
00:10:47,320 --> 00:10:49,900
 tidak mungkin untuk batas longgar, masuknya kode, 

221
00:10:49,900 --> 00:10:52,052
 untuk berpikir bahwa Anda telah melakukan operasi tanpa batas 

222
00:10:52,052 --> 00:10:55,130
 dengan pointer yang berasal dari ini tidak terdokumentasi 

223
00:10:55,130 --> 00:10:57,090
 Perpustakaan. 

224
00:10:57,090 --> 00:10:59,264
 Jadi apakah itu masuk akal? 

225
00:10:59,264 --> 00:11:00,930
 Jadi idenya adalah bahwa dalam kode yang diinstrumentasi 

226
00:11:00,930 --> 00:11:03,110
 kami akan selalu melakukan perbandingan ini 

227
00:11:03,110 --> 00:11:06,720
 dengan pointer, tetapi jika kita selalu mengatur batas 

228
00:11:06,720 --> 00:11:09,618
 entri untuk kode penunjuk tidak didokumentasikan 2 ke 31, 

229
00:11:09,618 --> 00:11:13,000
 Anda tidak akan pernah memiliki kesalahan dereference. 

230
00:11:13,000 --> 00:11:17,560
 OK jadi itu pada dasarnya bagaimana kita memiliki interoperabilitas yang bagus ini 

231
00:11:17,560 --> 00:11:20,542
 antara masuknya kode batas longgar di antaranya 

232
00:11:20,542 --> 00:11:24,320
 noninstrumented dari perpustakaan warisan rak. 

233
00:11:24,320 --> 00:11:27,010
 Jadi menyusun semuanya, apa arti dari semua ini? 

234
00:11:27,010 --> 00:11:28,830
 Jadi, kami memiliki sistem ini di sini 

235
00:11:28,830 --> 00:11:31,330
 bagus karena tidak membuat perpustakaan yang tidak terdokumentasi 

236
00:11:31,330 --> 00:11:34,828
 meledak, tapi satu masalah adalah kita tidak bisa mendeteksi 

237
00:11:34,828 --> 00:11:37,400
 dari pointer batas yang dihasilkan 

238
00:11:37,400 --> 00:11:39,830
 dalam kode uninstrumented, benar. 

239
00:11:39,830 --> 00:11:42,766
 Karena kita tidak akan pernah menetapkan yang tinggi misalnya, 

240
00:11:42,766 --> 00:11:44,790
 jika pointer [INAUDIBLE] terlalu besar, 

241
00:11:44,790 --> 00:11:46,590
 atau terlalu kecil atau semacamnya. 

242
00:11:46,590 --> 00:11:48,430
 Jadi kami sebenarnya tidak dapat memberikan keamanan memori 

243
00:11:48,430 --> 00:11:51,730
 untuk operasi yang terjadi dalam kode yang tidak didokumentasikan. 

244
00:11:51,730 --> 00:11:54,770
 Anda juga tidak dapat mendeteksi ketika kami melewati batas 

245
00:11:54,770 --> 00:11:58,300
 penunjuk dari kode yang diinstrumentasi ke kode yang tidak didokumentasikan. 

246
00:11:58,300 --> 00:11:59,842
 Sesuatu yang gila bisa terjadi, benar. 

247
00:11:59,842 --> 00:12:01,758
 Karena ingat jika Anda memiliki ini di luar batas 

248
00:12:01,758 --> 00:12:03,370
 menariknya dari kode yang diinstrumentasi 

249
00:12:03,370 --> 00:12:05,210
 itu memiliki bit set tinggi ke 1, benar. 

250
00:12:05,210 --> 00:12:07,466
 Jadi kelihatannya super ginormous. 

251
00:12:07,466 --> 00:12:09,924
 Sekarang kita tahu jika kita menyimpan kode itu dalam kode yang diinstrumentasi, 

252
00:12:09,924 --> 00:12:11,507
 kita mungkin menghapus bendera itu di beberapa titik 

253
00:12:11,507 --> 00:12:13,340
 jika itu kembali dalam batas. 

254
00:12:13,340 --> 00:12:15,391
 Tetapi jika kita hanya melewati alamat ginormous ini 

255
00:12:15,391 --> 00:12:17,240
 untuk kode yang tidak didokumentasikan, lalu siapa yang tahu, 

256
00:12:17,240 --> 00:12:20,000
 mungkin mencoba untuk dereference itu, mungkin melakukan sesuatu yang gila. 

257
00:12:20,000 --> 00:12:22,297
 Bahkan mungkin membawa pointer itu kembali ke batas, 

258
00:12:22,297 --> 00:12:23,880
 tetapi kita tidak akan pernah memiliki kesempatan 

259
00:12:23,880 --> 00:12:25,990
 untuk membersihkan bit yang tinggi itu, benar. 

260
00:12:25,990 --> 00:12:27,854
 Jadi Anda bisa naik-- Anda masih bisa datang 

261
00:12:27,854 --> 00:12:30,040
 dengan beberapa masalah inter-op di sana, bahkan jika kita 

262
00:12:30,040 --> 00:12:34,190
 gunakan skema ini di sini. 

263
00:12:34,190 --> 00:12:38,911
 OK, jadi itu pada dasarnya bagaimana batas longgar bekerja pada 32-- 

264
00:12:38,911 --> 00:12:39,702
 kamu punya pertanyaan? 

265
00:12:39,702 --> 00:12:41,951
 AUDIENCE: Ya, jadi jika Anda memiliki kode instrumen 

266
00:12:41,951 --> 00:12:43,799
 bertemu seperti memori yang dialokasikan, apakah itu 

267
00:12:43,799 --> 00:12:46,460
 menggunakan malloc yang sama dengan kode atribut yang digunakan, atau? 

268
00:12:46,460 --> 00:12:48,001
 PROFESOR: Ya jadi agak halus. 

269
00:12:48,001 --> 00:12:50,295
 Jadi seperti dalam kasus ini di sini, ini seperti sangat kejam 

270
00:12:50,295 --> 00:12:53,300
 apa yang terjadi, karena hanya ada dua wilayah, salah satunya 

271
00:12:53,300 --> 00:12:55,294
 digunakan oleh setiap set hal. 

272
00:12:55,294 --> 00:12:57,784
 Jadi sebenarnya tergantung pada apakah mereka menggunakan [tidak terdengar] 

273
00:12:57,784 --> 00:12:58,617
 dan hal-hal seperti itu. 

274
00:12:58,617 --> 00:13:01,768
 Anda juga dapat membayangkan bahwa seperti di C ++ [tidak terdengar] misalnya, 

275
00:13:01,768 --> 00:13:03,760
 Anda dapat menentukan alokator Anda sendiri, benar. 

276
00:13:03,760 --> 00:13:06,748
 Jadi itu semacam tergantung [tidak terdengar]. 

277
00:13:06,748 --> 00:13:10,732
 AUDIENCE: [INAUDIBLE] masukan yang sama, 

278
00:13:10,732 --> 00:13:13,720
 bagaimana pengalokasi tahu apakah atau tidak 

279
00:13:13,720 --> 00:13:15,627
 untuk mengatur 31 atau [TIDAK JELAS]. 

280
00:13:15,627 --> 00:13:17,960
 PROFESOR: Ya jadi pada tingkat yang lebih rendah, biasanya caranya 

281
00:13:17,960 --> 00:13:19,543
 bahwa algoritma alokasi ini berfungsi, 

282
00:13:19,543 --> 00:13:23,139
 adalah bahwa Anda memanggil sistem tidak dikenal [tidak terdengar] atau sesuatu 

283
00:13:23,139 --> 00:13:24,680
 seperti itu, semacam memindahkan pointer ke atas. 

284
00:13:24,680 --> 00:13:27,397
 Jadi dapat Anda bayangkan jika Anda memiliki banyak pengalokasi, semuanya mencoba 

285
00:13:27,397 --> 00:13:29,290
 untuk mengalokasikan memori, masing-masing memiliki 

286
00:13:29,290 --> 00:13:32,316
 potongan memori mereka sendiri yang mereka miliki untuk diri mereka sendiri 

287
00:13:32,316 --> 00:13:33,460
 pada dasarnya, benar. 

288
00:13:33,460 --> 00:13:36,251
 Jadi dalam kehidupan nyata mungkin lebih terfragmentasi dari ini, 

289
00:13:36,251 --> 00:13:39,730
 itu pada dasarnya pada tingkat tinggi, cara kerjanya. 

290
00:13:39,730 --> 00:13:43,130
 OK jadi ini adalah batas longgar pada sistem 32-bit. 

291
00:13:43,130 --> 00:13:45,516
 Jadi seperti yang Anda semua tahu sistem 64-bit adalah lebah 

292
00:13:45,516 --> 00:13:47,910
 lutut hari ini, jadi bagaimana batas baggy 

293
00:13:47,910 --> 00:13:50,276
 bekerja pada sistem tersebut? 

294
00:13:50,276 --> 00:13:51,900
 Nah, dalam sistem itu Anda bisa benar-benar 

295
00:13:51,900 --> 00:13:55,170
 singkirkan tabel batas, karena kita bisa benar-benar 

296
00:13:55,170 --> 00:13:58,871
 simpan beberapa informasi tentang batas, dari penunjuk 

297
00:13:58,871 --> 00:13:59,370
 diri. 

298
00:13:59,370 --> 00:14:02,032


299
00:14:02,032 --> 00:14:06,514
 Jadi bayangkan kita akan melihat pointer biasa 

300
00:14:06,514 --> 00:14:09,010
 dalam sistem batas longgar. 

301
00:14:09,010 --> 00:14:11,638
 Jadi kita bisa menggunakannya, seperti ini. 

302
00:14:11,638 --> 00:14:15,110


303
00:14:15,110 --> 00:14:18,330
 Jadi kita bisa-- jika pointer dalam batasan, 

304
00:14:18,330 --> 00:14:21,690
 pada dasarnya kita dapat mengatur 21 bit pertama menjadi 0. 

305
00:14:21,690 --> 00:14:24,340
 Kita dapat menempatkan ukuran dalam 5 bit ini di sini. 

306
00:14:24,340 --> 00:14:27,610
 Dan sekali lagi ini mewakili basis log 2 

307
00:14:27,610 --> 00:14:28,770
 pada ukuran di sini. 

308
00:14:28,770 --> 00:14:31,970
 Dan kemudian kita miliki di sini, di sisa 38 bit, 

309
00:14:31,970 --> 00:14:33,662
 hanya bit alamat biasa. 

310
00:14:33,662 --> 00:14:35,370
 Sekarang alasan mengapa ini tidak secara besar-besaran 

311
00:14:35,370 --> 00:14:37,850
 membatasi ukuran alamat program yang Anda gunakan, 

312
00:14:37,850 --> 00:14:39,960
 adalah bahwa banyak bit orde tinggi ini, 

313
00:14:39,960 --> 00:14:41,908
 sistem operasi dan atau perangkat kerasnya, 

314
00:14:41,908 --> 00:14:45,317
 tidak membiarkan aplikasi digunakan, karena berbagai alasan, benar. 

315
00:14:45,317 --> 00:14:47,180
 Jadi ternyata, kami tidak secara dramatis 

316
00:14:47,180 --> 00:14:49,268
 mengecilkan jumlah aplikasi [TIDAK JELAS] 

317
00:14:49,268 --> 00:14:51,062
 Anda gunakan dalam sistem. 

318
00:14:51,062 --> 00:14:52,894
 Seperti inilah tampilan pointer biasa. 

319
00:14:52,894 --> 00:14:53,810
 Sekarang apa yang terjadi ketika kita hanya punya 

320
00:14:53,810 --> 00:14:55,280
 salah satunya dari batas-batas pointer? 

321
00:14:55,280 --> 00:14:57,290
 Nah, dalam sistem 32-bit semua bisa kita lakukan pada dasarnya 

322
00:14:57,290 --> 00:14:59,570
 hanya mengatur agar sedikit tinggi dan Anda hanya 

323
00:14:59,570 --> 00:15:02,990
 berharap hal itu tidak pernah melebihi 1/2 slot jauhnya 

324
00:15:02,990 --> 00:15:05,119
 dari pangkalan itu. 

325
00:15:05,119 --> 00:15:08,053
 Tapi sekarang kita memiliki semua ruang alamat ekstra ini di sini, 

326
00:15:08,053 --> 00:15:13,760
 Anda benar-benar dapat menyingkirkan batas yang diimbangi secara langsung 

327
00:15:13,760 --> 00:15:14,912
 di pointer ini. 

328
00:15:14,912 --> 00:15:18,020


329
00:15:18,020 --> 00:15:20,075
 Jadi kita bisa melakukan sesuatu seperti ini. 

330
00:15:20,075 --> 00:15:25,230


331
00:15:25,230 --> 00:15:29,300
 Jadi kita bisa memiliki 13 bit di sini untuk mengimbangi, kan, 

332
00:15:29,300 --> 00:15:30,460
 offset tidak terikat. 

333
00:15:30,460 --> 00:15:33,740
 Seberapa jauh ini keluar dari batas penunjuk, dari tempat itu 

334
00:15:33,740 --> 00:15:35,050
 dimana seharusnya? 

335
00:15:35,050 --> 00:15:39,280
 Dan kemudian sekali lagi Anda dapat menempatkan ukuran yang sebenarnya 

336
00:15:39,280 --> 00:15:42,240
 dari objek yang dimaksud di sini. 

337
00:15:42,240 --> 00:15:44,112
 Ini akan menjadi 0 sekali lagi. 

338
00:15:44,112 --> 00:15:48,740
 Dan ini akan menjadi basis alamat sebenarnya di sini. 

339
00:15:48,740 --> 00:15:51,430
 Dan ini mungkin mengingatkan Anda 

340
00:15:51,430 --> 00:15:53,290
 dari beberapa jenis representasi penunjuk fakta, 

341
00:15:53,290 --> 00:15:55,190
 tapi ada beberapa kelebihan 

342
00:15:55,190 --> 00:15:57,800
 di sini, sekarang kita bergerak di dunia 64-bit. 

343
00:15:57,800 --> 00:16:00,870
 Jadi pertama-tama, Anda akan perhatikan bahwa petunjuk tag ini, 

344
00:16:00,870 --> 00:16:04,000
 ini adalah ukuran biasa dari penunjuk biasa, benar. 

345
00:16:04,000 --> 00:16:07,860
 Pointer masih lebar 64-bit di kedua pengaturan ini. 

346
00:16:07,860 --> 00:16:10,180
 Jadi itu bagus karena itu berarti misalnya, 

347
00:16:10,180 --> 00:16:13,280
 itu berarti dan hak untuk pointer itu adalah waktu. 

348
00:16:13,280 --> 00:16:14,905
 Tidak seperti di dunia jari gemuk tradisional, 

349
00:16:14,905 --> 00:16:16,779
 di mana Anda benar-benar harus menggunakan beberapa kata 

350
00:16:16,779 --> 00:16:18,042
 mewakili penunjuk lemak itu. 

351
00:16:18,042 --> 00:16:19,125
 Jadi itu bagus. 

352
00:16:19,125 --> 00:16:22,570
 Dan juga perhatikan bahwa kita dapat dengan mudah menanyakan hal-hal ini, 

353
00:16:22,570 --> 00:16:24,300
 kode tidak terdokumentasi, karena mereka 

354
00:16:24,300 --> 00:16:27,312
 bekerja dan berukuran sama dengan pointer biasa. 

355
00:16:27,312 --> 00:16:29,270
 Kita dapat menempatkan hal-hal ini di dalam struct misalnya, 

356
00:16:29,270 --> 00:16:32,080
 dan ukuran dari struct itu tidak akan berubah. 

357
00:16:32,080 --> 00:16:36,470
 Jadi ini sangat bagus jika kita bisa bekerja di dunia 64-bit. 

358
00:16:36,470 --> 00:16:39,166
 Jadi apakah itu semua masuk akal? 

359
00:16:39,166 --> 00:16:42,798
 AUDIENCE: Jadi mengapa ada delapan 0-bit [tidak terdengar] 

360
00:16:42,798 --> 00:16:43,680
 penunjuk di sana? 

361
00:16:43,680 --> 00:16:47,550
 Di mana seperti bit ukuran 5 sebelumnya tidak. 

362
00:16:47,550 --> 00:16:49,590
 PROFESOR: Jadi Anda berbicara tentang di sini? 

363
00:16:49,590 --> 00:16:50,965
 AUDIENCE: Ya, apakah ada alasannya 

364
00:16:50,965 --> 00:16:53,320
 mengapa kita tidak bisa hanya menyimpan [tidak terdengar] 

365
00:16:53,320 --> 00:16:54,935
 jika kita seperti enam 0-bit di sana dan punya 

366
00:16:54,935 --> 00:16:57,720
 lebih banyak bit untuk offset, seperti mengapa angka 8? 

367
00:16:57,720 --> 00:17:00,475
 PROFESOR: Jadi saya pikir demikian dalam beberapa kasus 

368
00:17:00,475 --> 00:17:02,808
 ada masalah garis tertentu yang harus kita tangani. 

369
00:17:02,808 --> 00:17:05,825
 Masalah [TIDAK JELAS] adalah berurusan dengan jika bit lebih tinggi. 

370
00:17:05,825 --> 00:17:07,325
 Saya tidak berpikir, pada prinsipnya, ada 

371
00:17:07,325 --> 00:17:08,866
 alasan apa pun mengapa Anda tidak bisa membaca beberapa 

372
00:17:08,866 --> 00:17:10,089
 dari hal-hal ini [tidak terdengar]. 

373
00:17:10,089 --> 00:17:11,589
 Mungkin ada beberapa versi yang sulit 

374
00:17:11,589 --> 00:17:13,127
 yang tidak saya pikirkan saat ini, 

375
00:17:13,127 --> 00:17:15,002
 tetapi [tidak terdengar] beberapa di antaranya harus 0 

376
00:17:15,002 --> 00:17:17,929
 atau perangkat keras akan menyebabkan masalah. 

377
00:17:17,930 --> 00:17:21,079


378
00:17:21,079 --> 00:17:23,310
 Ada pertanyaan lain? 

379
00:17:23,310 --> 00:17:26,380
 OK jadi, selanjutnya kamu bertanya-tanya 

380
00:17:26,380 --> 00:17:28,550
 adalah, bisakah Anda tetap meluncurkan buffer 

381
00:17:28,550 --> 00:17:30,355
 meluap dalam sistem batas longgar, 

382
00:17:30,355 --> 00:17:32,480
 jelas karena saya memberi Anda kertas lain untuk dibaca, 

383
00:17:32,480 --> 00:17:34,220
 begitu jelas hal ini, ini tidak menyelesaikan semua masalah, 

384
00:17:34,220 --> 00:17:34,970
 kanan? 

385
00:17:34,970 --> 00:17:36,610
 Jadi satu masalah yang mungkin Anda hadapi 

386
00:17:36,610 --> 00:17:38,735
 adalah jika Anda memiliki kode yang tidak didokumentasikan sekali lagi, 

387
00:17:38,735 --> 00:17:41,510
 kami tidak dapat mendeteksi masalah apa pun dalam kode yang tidak didokumentasikan. 

388
00:17:41,510 --> 00:17:44,550
 Anda juga bisa menemukan kerentanan memori 

389
00:17:44,550 --> 00:17:47,380
 yang muncul dari sistem alokasi memori dinamis. 

390
00:17:47,380 --> 00:17:48,921
 Jadi kalau bisa ingat di kuliah 

391
00:17:48,921 --> 00:17:52,990
 kami melihat pointer aneh malloc gratis yang aneh ini 

392
00:17:52,990 --> 00:17:54,090
 hal yang terjadi. 

393
00:17:54,090 --> 00:17:55,980
 Batas baggy tidak selalu mencegah Anda 

394
00:17:55,980 --> 00:17:57,500
 dari beberapa hal itu. 

395
00:17:57,500 --> 00:18:00,130
 Kami juga membahas kuliah terakhir, di mana 

396
00:18:00,130 --> 00:18:02,654
 fakta bahwa penunjuk kode tidak memiliki batas 

397
00:18:02,654 --> 00:18:04,260
 terkait dengan mereka, benar. 

398
00:18:04,260 --> 00:18:07,240
 Jadi sekarang Anda memiliki struct yang memiliki buffer di bagian bawah, 

399
00:18:07,240 --> 00:18:09,140
 ini memiliki fungsi penunjuk di bagian atas, 

400
00:18:09,140 --> 00:18:12,050
 jika Anda memiliki buffer overflow ke penunjuk fungsi itu, 

401
00:18:12,050 --> 00:18:12,550
 kanan. 

402
00:18:12,550 --> 00:18:14,220
 Katakanlah buffer overflow masih ada 

403
00:18:14,220 --> 00:18:15,280
 dalam batas longgar. 

404
00:18:15,280 --> 00:18:17,910
 Jadi Anda telah menimpa fungsi pointer itu. 

405
00:18:17,910 --> 00:18:20,020
 Kami akan mencoba menjalankan penunjuk fungsi itu, 

406
00:18:20,020 --> 00:18:22,100
 itu bisa menunjuk pada sesuatu untuk, 

407
00:18:22,100 --> 00:18:23,840
 menyerang sepotong kendali memori. 

408
00:18:23,840 --> 00:18:24,950
 OK, dan batasan tidak akan membantu dengan itu, 

409
00:18:24,950 --> 00:18:26,814
 karena tidak ada batasan yang dikaitkan dengan fungsi 

410
00:18:26,814 --> 00:18:27,313
 petunjuk. 

411
00:18:27,313 --> 00:18:30,076


412
00:18:30,076 --> 00:18:36,562
 Dan secara umum, berapa biaya batas longgar? 

413
00:18:36,562 --> 00:18:38,860
 Jadi pada dasarnya ada empat. 

414
00:18:38,860 --> 00:18:43,120
 Jadi biaya pertama adalah ruang, benar. 

415
00:18:43,120 --> 00:18:44,495
 Jadi jika Anda menggunakan penunjuk lemak, 

416
00:18:44,495 --> 00:18:47,120
 jelas Anda harus membuat pointer lebih besar. 

417
00:18:47,120 --> 00:18:49,821
 Tetapi jika Anda menggunakan sistem batas longgar yang kita hanya 

418
00:18:49,821 --> 00:18:52,112
 dibahas, Anda harus menyimpan tabel batas, benar. 

419
00:18:52,112 --> 00:18:55,600
 Jadi tabel batas memiliki ukuran slot itu 

420
00:18:55,600 --> 00:18:58,090
 yang memungkinkan Anda untuk mengontrol seberapa besar batas tabel itu, 

421
00:18:58,090 --> 00:19:02,140
 tetapi Anda masih bisa menggunakan memori [TIDAK JELAS] untuk itu. 

422
00:19:02,140 --> 00:19:08,370
 Anda juga mendapatkan overhead CPU untuk melakukan semua penunjuk 

423
00:19:08,370 --> 00:19:09,800
 instrumentasi, benar. 

424
00:19:09,800 --> 00:19:13,420
 Jadi untuk setiap, atau dekat dengan setiap hal penunjuk yang Anda lakukan, 

425
00:19:13,420 --> 00:19:16,880
 Anda harus memeriksa batas-batas ini menggunakan operasi-operasi shift 

426
00:19:16,880 --> 00:19:18,040
 dan hal-hal seperti itu. 

427
00:19:18,040 --> 00:19:21,140
 Jadi itu akan memperlambat program Anda. 

428
00:19:21,140 --> 00:19:26,890
 Ada juga masalah ini dengan alarm palsu, benar. 

429
00:19:26,890 --> 00:19:29,624
 Jadi seperti yang kita diskusikan, mungkin itu masalahnya 

430
00:19:29,624 --> 00:19:31,540
 bahwa program menghasilkan dari pointer terikat 

431
00:19:31,540 --> 00:19:33,360
 tetapi tidak pernah mencoba untuk dereference itu, benar. 

432
00:19:33,360 --> 00:19:35,520
 Sebenarnya itu bukan masalah. 

433
00:19:35,520 --> 00:19:37,560
 Batas longgar akan menandai kreasi 

434
00:19:37,560 --> 00:19:39,250
 dari orang-orang di luar batas pointer, jika mereka 

435
00:19:39,250 --> 00:19:42,660
 melampaui 1/2 ukuran slot, setidaknya dalam solusi 32-bit, 

436
00:19:42,660 --> 00:19:43,160
 kanan. 

437
00:19:43,160 --> 00:19:45,460
 Dan apa yang akan Anda lihat dengan banyak alat keamanan, 

438
00:19:45,460 --> 00:19:48,362
 adalah bahwa alarm palsu benar-benar mengurangi kemungkinan itu 

439
00:19:48,362 --> 00:19:50,320
 bahwa orang-orang akan menggunakan alat Anda, benar. 

440
00:19:50,320 --> 00:19:52,330
 Karena dalam prakteknya kita semua berharap 

441
00:19:52,330 --> 00:19:54,547
 bahwa kita peduli dengan keamanan, tetapi sebenarnya 

442
00:19:54,547 --> 00:19:55,630
 apa yang orang pedulikan? 

443
00:19:55,630 --> 00:19:57,720
 Mereka ingin dapat mengunggah foto Facebook mereka yang konyol 

444
00:19:57,720 --> 00:19:59,070
 dan hal-hal kehidupan, dan mereka menginginkannya 

445
00:19:59,070 --> 00:20:01,130
 mampu membuat semuanya berjalan cepat dan hal-hal seperti itu. 

446
00:20:01,130 --> 00:20:03,160
 Jadi Anda benar-benar menginginkan alat keamanan Anda 

447
00:20:03,160 --> 00:20:07,240
 mungkin memiliki lebih sedikit cakupan menemukan bug, 

448
00:20:07,240 --> 00:20:09,520
 tetapi sebenarnya memiliki 0 alarm palsu. 

449
00:20:09,520 --> 00:20:12,230
 Berbeda dengan menangkap semua jenis kerentanan keamanan, 

450
00:20:12,230 --> 00:20:14,020
 tapi mungkin ada alarm palsu 

451
00:20:14,020 --> 00:20:16,790
 yang akan mengiritasi pengembang, atau menjengkelkan pengguna. 

452
00:20:16,790 --> 00:20:19,040
 Dan biaya lain yang Anda miliki untuk ini akhirnya, 

453
00:20:19,040 --> 00:20:25,770
 adalah bahwa Anda memerlukan dukungan kompilator, benar. 

454
00:20:25,770 --> 00:20:27,640
 Yang benar-benar dapat berakhir dengan tidak trivial, 

455
00:20:27,640 --> 00:20:28,570
 karena kamu harus masuk kesana, kamu 

456
00:20:28,570 --> 00:20:30,360
 harus menambahkan semua instrumentasi, 

457
00:20:30,360 --> 00:20:32,610
 merangkak cek pointer, dan seterusnya ans sebagainya. 

458
00:20:32,610 --> 00:20:35,330
 Jadi pada dasarnya biaya pemeriksaan batas ini 

459
00:20:35,330 --> 00:20:37,000
 pendekatan. 

460
00:20:37,000 --> 00:20:42,120
 Jadi itu menyimpulkan diskusi tentang batas longgar. 

461
00:20:42,120 --> 00:20:45,010
 Dan sekarang kita benar-benar dapat memikirkan dua mitigasi lainnya 

462
00:20:45,010 --> 00:20:46,570
 strategi untuk buffer overflows. 

463
00:20:46,570 --> 00:20:49,600
 Mereka sebenarnya lebih mudah untuk dijelaskan dan dimengerti. 

464
00:20:49,600 --> 00:20:55,090
 Jadi salah satu pendekatan ini disebut memori yang tidak dapat dieksekusi. 

465
00:20:55,090 --> 00:21:00,570


466
00:21:00,570 --> 00:21:04,600
 Dan ide dasarnya adalah perangkat paging 

467
00:21:04,600 --> 00:21:08,830
 akan menentukan 3-bit untuk setiap halaman 

468
00:21:08,830 --> 00:21:12,064
 yang Anda miliki dalam memori, baca, tulis, dan eksekusi, benar. 

469
00:21:12,064 --> 00:21:13,980
 Dapatkah program membaca memori itu, menuliskannya, 

470
00:21:13,980 --> 00:21:14,720
 jalankan itu. 

471
00:21:14,720 --> 00:21:16,380
 2 bit pertama sudah tua, mereka sudah 

472
00:21:16,380 --> 00:21:18,600
 sudah ada selama beberapa waktu, yang terakhir sebenarnya 

473
00:21:18,600 --> 00:21:19,764
 konstruksi yang cukup baru. 

474
00:21:19,764 --> 00:21:21,430
 Dan gagasannya adalah bahwa Anda dapat benar-benar 

475
00:21:21,430 --> 00:21:24,790
 membuat stack tidak bisa dieksekusi, benar. 

476
00:21:24,790 --> 00:21:26,960
 Jadi jika Anda membuat stack non-executable 

477
00:21:26,960 --> 00:21:29,110
 itu berarti musuh tidak dapat menjalankan kode 

478
00:21:29,110 --> 00:21:31,440
 hanya dengan menunjuk-- dengan membuat kode shell itu 

479
00:21:31,440 --> 00:21:34,840
 dan kemudian semacam melompat ke suatu tempat di buffer itu. 

480
00:21:34,840 --> 00:21:39,470
 Dan apa yang banyak sistem lakukan, apakah mereka benar-benar spesifik 

481
00:21:39,470 --> 00:21:43,190
 kebijakan seperti ini. 

482
00:21:43,190 --> 00:21:46,690
 Jadi benar eksklusif atau x, yang berarti jika Anda memilikinya 

483
00:21:46,690 --> 00:21:49,730
 halaman tertentu, Anda dapat menulis untuk itu, 

484
00:21:49,730 --> 00:21:52,070
 atau Anda dapat memperlakukannya sebagai kode yang dapat dieksekusi, 

485
00:21:52,070 --> 00:21:53,542
 tetapi Anda tidak bisa melakukan keduanya. 

486
00:21:53,542 --> 00:21:55,000
 OK dan jadi sekali lagi, pergi 

487
00:21:55,000 --> 00:21:56,450
 untuk mencegah penyerang dari adil 

488
00:21:56,450 --> 00:21:58,250
 menempatkan kode yang dapat dieksekusi dalam tumpukan 

489
00:21:58,250 --> 00:22:00,380
 dan kemudian langsung menuju ke sana. 

490
00:22:00,380 --> 00:22:02,890
 Jadi ini-- seharusnya cukup mudah, benar. 

491
00:22:02,890 --> 00:22:06,850
 Jadi kami telah menghapus, pada tingkat perangkat keras, serangan ini 

492
00:22:06,850 --> 00:22:09,920
 vektor penyerang menempatkan kode yang dapat dieksekusi dalam tumpukan. 

493
00:22:09,920 --> 00:22:11,210
 Jadi apa yang baik tentang ini? 

494
00:22:11,210 --> 00:22:14,670
 Nah berpotensi ini bekerja tanpa ada perubahan 

495
00:22:14,670 --> 00:22:16,190
 ke aplikasi, benar. 

496
00:22:16,190 --> 00:22:18,610
 Ini semua terjadi di level perangkat keras 

497
00:22:18,610 --> 00:22:20,660
 dan pada tingkat OS, dengan OS saja 

498
00:22:20,660 --> 00:22:23,350
 pastikan halaman dilindungi dengan bit-bit ini, oke. 

499
00:22:23,350 --> 00:22:24,725
 Jadi itu sangat, sangat gila, benar. 

500
00:22:24,725 --> 00:22:27,183
 Karena Anda tidak perlu khawatir tentang dukungan kompilator ini 

501
00:22:27,183 --> 00:22:28,210
 masalah yang kami punya di sini. 

502
00:22:28,210 --> 00:22:30,250
 Hal bagus lainnya adalah, seperti yang saya sebutkan 

503
00:22:30,250 --> 00:22:32,210
 di kuliah terakhir, perangkat keras 

504
00:22:32,210 --> 00:22:35,320
 selalu memperhatikanmu, meskipun OSnya tidak benar. 

505
00:22:35,320 --> 00:22:37,520
 Jadi bit-bit ini dikatakan di sini, 

506
00:22:37,520 --> 00:22:40,060
 Anda tahu mereka melihat dan memverifikasi 

507
00:22:40,060 --> 00:22:42,415
 untuk kebenaran di setiap referensi memori 

508
00:22:42,415 --> 00:22:43,850
 yang Anda buat dengan kode. 

509
00:22:43,850 --> 00:22:46,930
 Itu aspek yang sangat bagus dari ini juga. 

510
00:22:46,930 --> 00:22:49,460
 Sekarang satu kelemahan dari sistem ini 

511
00:22:49,460 --> 00:22:52,260
 meskipun, itu membuat aplikasi lebih sulit 

512
00:22:52,260 --> 00:22:56,990
 untuk menghasilkan kode secara dinamis, dalam kasus jinak atau murah hati. 

513
00:22:56,990 --> 00:22:59,880
 Dan contoh terbaiknya adalah, just-in-time 

514
00:22:59,880 --> 00:23:02,480
 kompiler yang kita diskusikan dari kuliah terakhir, benar. 

515
00:23:02,480 --> 00:23:04,150
 Jadi bagaimana Anda bisa pergi ke web 

516
00:23:04,150 --> 00:23:06,100
 halaman dan kode JavaScript Anda mengeksekusi cepat. 

517
00:23:06,100 --> 00:23:07,650
 Ini mengunduh sumber JavaScript itu, 

518
00:23:07,650 --> 00:23:09,826
 awalnya mungkin mulai hanya menafsirkannya, 

519
00:23:09,826 --> 00:23:11,200
 tetapi kemudian pada titik tertentu itu terjadi 

520
00:23:11,200 --> 00:23:12,999
 untuk menemukan beberapa jalur panas, beberapa lingkaran panas 

521
00:23:12,999 --> 00:23:14,790
 dan kemudian itu akan menghasilkan secara dinamis 

522
00:23:14,790 --> 00:23:17,884
 kode mesin x86 dan jalankan itu secara langsung, benar. 

523
00:23:17,884 --> 00:23:20,550
 Tetapi untuk membuatnya bekerja Anda harus bisa menulis secara dinamis 

524
00:23:20,550 --> 00:23:23,400
 kode ke halaman. 

525
00:23:23,400 --> 00:23:25,990
 Jadi ada beberapa cara Anda bisa menggunakan ini misalnya, 

526
00:23:25,990 --> 00:23:28,620
 Anda dapat membayangkan bahwa kompilator just-in-time awalnya 

527
00:23:28,620 --> 00:23:31,580
 setel bit tulis dan kemudian menghapus sedikit tulis, 

528
00:23:31,580 --> 00:23:32,950
 lalu set bit eksekusi. 

529
00:23:32,950 --> 00:23:34,770
 Ada beberapa cara yang bisa Anda lakukan untuk mengatasinya, 

530
00:23:34,770 --> 00:23:36,603
 tetapi terkadang bisa sedikit rumit. 

531
00:23:36,603 --> 00:23:39,227
 Pada tingkat yang lebih tinggi, begitulah cara kerja memori yang tidak dapat dieksekusi, 

532
00:23:39,227 --> 00:23:40,310
 cukup mudah dimengerti. 

533
00:23:40,310 --> 00:23:44,158
 AUDIENCE: Apa definisi seperti dieksekusi 

534
00:23:44,158 --> 00:23:44,772
 instruksi? 

535
00:23:44,772 --> 00:23:46,563
 Jadi jika Anda mengubah attenuator [tidak terdengar] 

536
00:23:46,563 --> 00:23:47,525
 itu tidak dianggap sebagai instruksi yang dapat dieksekusi. 

537
00:23:47,525 --> 00:23:49,410
 PROFESOR: Yah pada dasarnya tidak. 

538
00:23:49,410 --> 00:23:53,220
 Bisakah Anda mengatur seperti instruksi pointer mendaftar ke nilai itu. 

539
00:23:53,220 --> 00:23:56,240
 Dengan kata lain, dapatkah Anda-- jika Anda memiliki banyak halaman memori, 

540
00:23:56,240 --> 00:23:58,580
 dapatkah Anda benar-benar mengatur EIP di sana dan benar-benar memulai 

541
00:23:58,580 --> 00:23:59,979
 mengeksekusi kode dari halaman itu. 

542
00:23:59,979 --> 00:24:00,520
 AUDIENCE: Ah. 

543
00:24:00,520 --> 00:24:03,520


544
00:24:03,520 --> 00:24:07,480
 PROFESOR: OK, jadi itu adalah memori yang tidak dapat dieksekusi. 

545
00:24:07,480 --> 00:24:09,710
 Dan teknik lain yang mungkin Anda lakukan 

546
00:24:09,710 --> 00:24:12,990
 bayangkan untuk melindungi terhadap buffer overflows 

547
00:24:12,990 --> 00:24:19,845
 menggunakan alamat acak atau ruang alamat. 

548
00:24:19,845 --> 00:24:26,410


549
00:24:26,410 --> 00:24:30,270
 Dan observasi di sini adalah, itu banyak sekali 

550
00:24:30,270 --> 00:24:35,080
 dari serangan yang telah kita bahas sejauh ini 

551
00:24:35,080 --> 00:24:39,590
 gunakan alamat berkode keras, benar. 

552
00:24:39,590 --> 00:24:42,140
 Dan jika Anda memikirkan banyak serangan 

553
00:24:42,140 --> 00:24:44,610
 Anda telah bekerja di lab Anda, bagaimana cara kerjanya? 

554
00:24:44,610 --> 00:24:47,140
 Anda membuka program di GDB, Anda mengetahuinya 

555
00:24:47,140 --> 00:24:49,840
 lokasi beberapa hal, Anda dapat membuat beberapa kode shell 

556
00:24:49,840 --> 00:24:52,700
 yang sebenarnya memiliki beberapa alamat berkode keras di sana, 

557
00:24:52,700 --> 00:24:53,200
 kanan. 

558
00:24:53,200 --> 00:24:55,390
 Jadi ide di balik basis alamat acak 

559
00:24:55,390 --> 00:24:55,890
 sederhana. 

560
00:24:55,890 --> 00:25:03,160
 Pada dasarnya Anda ingin menyulitkan penyerang 

561
00:25:03,160 --> 00:25:04,205
 untuk menebak alamat. 

562
00:25:04,205 --> 00:25:08,084


563
00:25:08,084 --> 00:25:09,500
 Jadi ada beberapa cara berbeda 

564
00:25:09,500 --> 00:25:11,230
 Anda bisa berpikir untuk melakukan ini, benar. 

565
00:25:11,230 --> 00:25:13,530
 Jadi satu ide adalah bahwa Anda dapat membayangkan memiliki 

566
00:25:13,530 --> 00:25:15,260
 pengacakan tumpukan, benar. 

567
00:25:15,260 --> 00:25:17,850
 Jadi bayangkan dari sini ke sini, 

568
00:25:17,850 --> 00:25:20,370
 ini adalah seluruh ruang memori virtual dari program ini, 

569
00:25:20,370 --> 00:25:20,870
 kanan. 

570
00:25:20,870 --> 00:25:22,870
 Saat kami mendeskripsikan hal ini kepada Anda sejauh ini, 

571
00:25:22,870 --> 00:25:24,690
 pada dasarnya tumpukan selalu dimulai 

572
00:25:24,690 --> 00:25:27,270
 dengan tempat khusus ini di sini, selalu turun, 

573
00:25:27,270 --> 00:25:30,360
 benar, dan kode program di sini dan heap selalu 

574
00:25:30,360 --> 00:25:31,470
 naik di sini. 

575
00:25:31,470 --> 00:25:35,030
 Dan semua seg-- semua segmen ini, tumpukan, heap, 

576
00:25:35,030 --> 00:25:38,350
 dan kode program, semuanya dimulai di lokasi yang terkenal. 

577
00:25:38,350 --> 00:25:40,950
 Jadi bayangkan misalnya, seperti jika catatan kuliah saya di sini 

578
00:25:40,950 --> 00:25:41,695
 adalah tumpukan. 

579
00:25:41,695 --> 00:25:44,070
 Anda dapat membayangkan alih-alih tumpukan selalu dimulai di sini 

580
00:25:44,070 --> 00:25:46,780
 di lokasi yang diketahui ini, mungkin Anda memulainya di sini, 

581
00:25:46,780 --> 00:25:47,947
 mungkin Anda memulainya di sini. 

582
00:25:47,947 --> 00:25:49,280
 Di tempat lain seperti itu, benar. 

583
00:25:49,280 --> 00:25:51,900
 Demikian pula Anda dapat membayangkan bahwa mungkin kode program yang mana 

584
00:25:51,900 --> 00:25:53,760
 dulu selalu mulai di sini, mungkin kita 

585
00:25:53,760 --> 00:25:56,616
 memulainya di sini, atau di sini, atau sesuatu seperti itu, benar. 

586
00:25:56,616 --> 00:25:58,490
 Jadi idenya sekarang adalah jika Anda, penyerang, 

587
00:25:58,490 --> 00:26:01,075
 kontrol salah satu biner ini, Anda bisa melihat di GDB 

588
00:26:01,075 --> 00:26:02,867
 dan mencari tahu di mana semua offset ini, 

589
00:26:02,867 --> 00:26:05,075
 tetapi mereka sebenarnya tidak akan membantu Anda mengetahuinya 

590
00:26:05,075 --> 00:26:07,190
 di mana offset itu ada di kode asli itu 

591
00:26:07,190 --> 00:26:09,190
 berjalan di server, kan. 

592
00:26:09,190 --> 00:26:12,320
 Jadi itulah ide dasar di balik ruang-ruang alamat acak ini 

593
00:26:12,320 --> 00:26:13,510
 sana. 

594
00:26:13,510 --> 00:26:15,312
 Dan ini mengambil keuntungan dari fakta 

595
00:26:15,312 --> 00:26:17,020
 bahwa banyak kode yang Anda hasilkan, 

596
00:26:17,020 --> 00:26:19,740
 tidak harus dimuat ke tempat tertentu di memori, 

597
00:26:19,740 --> 00:26:20,240
 kanan. 

598
00:26:20,240 --> 00:26:22,698
 Jadi kecuali Anda menulis seperti driver perangkat, atau sesuatu 

599
00:26:22,698 --> 00:26:25,350
 seperti, yang mungkin berinteraksi dengan beberapa perangkat keras itu 

600
00:26:25,350 --> 00:26:29,670
 membutuhkan alamat khusus ini 

601
00:26:29,670 --> 00:26:32,370
 termasuk dalam buffer khusus ini sehingga dapat menyalin informasi di dalamnya. 

602
00:26:32,370 --> 00:26:34,562
 Jika Anda tidak melakukan hal-hal seperti itu maka biasanya 

603
00:26:34,562 --> 00:26:36,020
 kode Anda akan dapat dipindah-pindah. 

604
00:26:36,020 --> 00:26:40,000
 Jadi pendekatan ini akan bekerja sangat baik dengan hal-hal semacam itu. 

605
00:26:40,000 --> 00:26:43,740
 Jadi sekali lagi pertanyaannya adalah, dapatkah Anda memanfaatkan ini? 

606
00:26:43,740 --> 00:26:45,196
 Tentunya jawabannya masih ya. 

607
00:26:45,196 --> 00:26:47,070
 Ada beberapa cara berbeda yang bisa Anda lakukan 

608
00:26:47,070 --> 00:26:50,460
 seperti yang akan kita diskusikan hari ini di makalah [INAUDIBLE], 

609
00:26:50,460 --> 00:26:53,779
 penyerang sebenarnya dapat mengekstrak keacakan, benar. 

610
00:26:53,779 --> 00:26:55,570
 Dan secara umum itulah cara Anda mengalahkan semua 

611
00:26:55,570 --> 00:26:56,850
 pendekatan acak ini. 

612
00:26:56,850 --> 00:26:58,857
 Anda membuatnya tidak acak, entah dengan mencari tahu 

613
00:26:58,857 --> 00:27:00,690
 benih acak yang dilakukan penyerang, 

614
00:27:00,690 --> 00:27:03,740
 atau entah bagaimana memanfaatkan fakta bahwa penyerang bocor 

615
00:27:03,740 --> 00:27:07,040
 informasi tentang lokasi acak dari hal-hal ini. 

616
00:27:07,040 --> 00:27:10,520


617
00:27:10,520 --> 00:27:12,020
 Dan hal lain yang menarik 

618
00:27:12,020 --> 00:27:15,250
 adalah bahwa untuk banyak serangan yang telah kita diskusikan sejauh ini, 

619
00:27:15,250 --> 00:27:18,060
 pada dasarnya kami telah menggunakan semacam alamat berkode keras ini, 

620
00:27:18,060 --> 00:27:21,300
 tetapi perhatikan bahwa penyerang belum tentu 

621
00:27:21,300 --> 00:27:23,740
 peduli tentang melompat ke alamat tertentu. 

622
00:27:23,740 --> 00:27:26,160
 Atau ada serangan yang disebut serangan heap, yang 

623
00:27:26,160 --> 00:27:29,260
 sebenarnya cukup lucu jika kamu orang jahat, kurasa. 

624
00:27:29,260 --> 00:27:32,050
 Jadi cara serangan heap ini berhasil 

625
00:27:32,050 --> 00:27:34,160
 adalah, bahwa penyerang pada dasarnya 

626
00:27:34,160 --> 00:27:37,280
 baru mulai mengalokasikan satu ton kode shell secara dinamis 

627
00:27:37,280 --> 00:27:39,341
 dan hanya memasukkannya secara acak ke dalam memori, kan. 

628
00:27:39,341 --> 00:27:41,007
 Ini sangat efektif jika Anda 

629
00:27:41,007 --> 00:27:44,870
 menggunakan seperti bahasa tingkat tinggi yang dinamis seperti JavaScript 

630
00:27:44,870 --> 00:27:45,490
 Katakanlah. 

631
00:27:45,490 --> 00:27:46,910
 Jadi pembaca tag sedang duduk dalam lingkaran yang ketat 

632
00:27:46,910 --> 00:27:49,201
 dan hanya menghasilkan sekelompok string kode shell, benar. 

633
00:27:49,201 --> 00:27:51,750
 Dan Anda cukup mengisi heap dengan semua kode shell ini 

634
00:27:51,750 --> 00:27:53,140
 string, benar. 

635
00:27:53,140 --> 00:27:55,820
 Sekarang penyerang mungkin tidak tahu di mana tepatnya 

636
00:27:55,820 --> 00:27:58,340
 lokasi adalah masing-masing string kode shell, 

637
00:27:58,340 --> 00:28:02,330
 tetapi jika Anda telah mengalokasikan 10s dari megabyte string kode shell 

638
00:28:02,330 --> 00:28:04,160
 lalu hanya melakukan lompatan acak, benar. 

639
00:28:04,160 --> 00:28:06,800
 Jika Anda entah bagaimana bisa mengendalikan salah satu dari ret pointer ini, 

640
00:28:06,800 --> 00:28:09,914
 maka hei, mungkin Anda akan mendarat di kode shell, benar. 

641
00:28:09,914 --> 00:28:11,330
 Dan satu trik yang benar-benar dapat Anda gunakan 

642
00:28:11,330 --> 00:28:14,200
 adalah hal yang disebut NOP sleds, yang juga cukup lucu. 

643
00:28:14,200 --> 00:28:18,590
 Jadi bayangkan jika Anda memiliki string kode shell, maka 

644
00:28:18,590 --> 00:28:20,640
 mungkin tidak berhasil jika Anda melompat ke tempat acak 

645
00:28:20,640 --> 00:28:22,720
 dalam string kode shell, karena mungkin tidak 

646
00:28:22,720 --> 00:28:24,330
 atur serangan dengan benar. 

647
00:28:24,330 --> 00:28:27,250
 Tapi mungkin barang-barang ini yang Anda muntahkan ke heap, 

648
00:28:27,250 --> 00:28:30,876
 pada dasarnya hanya satu ton NOP dan kemudian di bagian paling akhir 

649
00:28:30,876 --> 00:28:32,240
 Anda memiliki kode shell, benar. 

650
00:28:32,240 --> 00:28:33,910
 Ini sebenarnya cukup pintar, 

651
00:28:33,910 --> 00:28:36,690
 karena ini berarti bahwa sekarang Anda benar-benar bisa menyimpang 

652
00:28:36,690 --> 00:28:38,182
 tempat yang tepat di mana Anda melompat. 

653
00:28:38,182 --> 00:28:39,890
 Jika Anda melompat ke salah satu dari NOP ini 

654
00:28:39,890 --> 00:28:42,431
 semuanya hanya pergi ke boom, boom, boom, boom, boom, boom, boom, lalu 

655
00:28:42,431 --> 00:28:43,920
 kamu menekan kode shell, benar. 

656
00:28:43,920 --> 00:28:46,110
 Jadi seperti inilah orang-orang yang mungkin Anda miliki 

657
00:28:46,110 --> 00:28:47,090
 lihat di tim. 

658
00:28:47,090 --> 00:28:49,048
 Mereka menciptakan hal-hal semacam ini, benar. 

659
00:28:49,048 --> 00:28:49,980
 Ini adalah sebuah masalah. 

660
00:28:49,980 --> 00:28:51,956
 Jadi itu cara lain untuk berkeliling 

661
00:28:51,956 --> 00:28:53,330
 dari hal pengacakan ini, hanya 

662
00:28:53,330 --> 00:28:55,850
 dengan membuat kode pengacakan Anda tahan banting, 

663
00:28:55,850 --> 00:28:58,880
 jika itu masuk akal. 

664
00:28:58,880 --> 00:29:01,493
 OK jadi itu pada dasarnya diskusi tentang beberapa 

665
00:29:01,493 --> 00:29:03,120
 dari jenis keacakan yang dapat Anda gunakan. 

666
00:29:03,120 --> 00:29:05,400
 Ada juga beberapa ide aneh yang dimiliki orang-orang. 

667
00:29:05,400 --> 00:29:06,340
 Jadi sekarang Anda tahu itu ketika Anda menginginkannya 

668
00:29:06,340 --> 00:29:08,020
 untuk membuat panggilan sistem misalnya, 

669
00:29:08,020 --> 00:29:11,275
 Anda menggunakan fungsi libc syscall ini 

670
00:29:11,275 --> 00:29:13,157
 dan pada dasarnya Anda melewatkan nomor unik itu 

671
00:29:13,157 --> 00:29:15,490
 mewakili panggilan sistem yang ingin Anda buat, benar. 

672
00:29:15,490 --> 00:29:19,150
 Jadi mungkin empat tujuh dan mungkin tidur delapan, atau sesuatu 

673
00:29:19,150 --> 00:29:20,950
 seperti itu, benar. 

674
00:29:20,950 --> 00:29:23,280
 Jadi apa artinya jika penyerang dapat entah bagaimana 

675
00:29:23,280 --> 00:29:26,730
 cari tahu alamat instruksi syscall itu 

676
00:29:26,730 --> 00:29:29,420
 dan melompat ke sana entah bagaimana, dia dapat benar-benar hanya memasok 

677
00:29:29,420 --> 00:29:32,972
 nomor sistem panggilan yang ingin mereka panggil secara langsung, benar. 

678
00:29:32,972 --> 00:29:35,180
 Jadi, Anda bisa membayangkan bahwa setiap kali program berjalan, 

679
00:29:35,180 --> 00:29:39,290
 Anda benar-benar membuat penugasan dinamis dari nomor syscall 

680
00:29:39,290 --> 00:29:40,951
 ke syscall yang sebenarnya, benar. 

681
00:29:40,951 --> 00:29:42,950
 Untuk membuatnya lebih sulit bagi penyerang untuk mendapatkan barang. 

682
00:29:42,950 --> 00:29:45,250
 Bahkan ada beberapa proposal yang sangat avant garde 

683
00:29:45,250 --> 00:29:48,300
 untuk mengubah perangkat keras seperti perangkat keras sebenarnya 

684
00:29:48,300 --> 00:29:51,870
 mengandung kunci xor, yang digunakan untuk secara dinamis xor 

685
00:29:51,870 --> 00:29:53,130
 instruksi, benar. 

686
00:29:53,130 --> 00:29:55,500
 Bayangkan setiap kali Anda mengompilasi program, semuanya 

687
00:29:55,500 --> 00:29:58,570
 dari kode instruksi itulah xor dari beberapa kunci, benar. 

688
00:29:58,570 --> 00:30:00,590
 Kunci itu dimasukkan ke dalam daftar perangkat keras itu 

689
00:30:00,590 --> 00:30:02,370
 saat Anda pertama kali memuat program 

690
00:30:02,370 --> 00:30:04,450
 dan kemudian setiap kali Anda menjalankan instruksi, 

691
00:30:04,450 --> 00:30:06,620
 perangkat keras secara otomatis xor itu, 

692
00:30:06,620 --> 00:30:08,980
 sebelum Anda melanjutkan mengeksekusi instruksi itu, benar. 

693
00:30:08,980 --> 00:30:10,771
 Jadi apa yang baik tentang itu adalah, itu bahkan sekarang 

694
00:30:10,771 --> 00:30:12,700
 jika penyerang dapat menghasilkan kode shell, 

695
00:30:12,700 --> 00:30:14,450
 penyerang tidak tahu kunci itu, kan. 

696
00:30:14,450 --> 00:30:16,074
 Jadi sangat sulit bagi penyerang 

697
00:30:16,074 --> 00:30:18,020
 untuk mencari tahu apa yang tepatnya dimasukkan ke dalam memori. 

698
00:30:18,020 --> 00:30:19,520
 AUDIENCE: Tetapi jika dia bisa mendapatkan kode 

699
00:30:19,520 --> 00:30:23,219
 dan dia juga instruksi dia bisa memperbaruinya kembali 

700
00:30:23,219 --> 00:30:24,510
 untuk instruksi [tidak terdengar]. 

701
00:30:24,510 --> 00:30:25,140
 PROFESOR, Oh ya. 

702
00:30:25,140 --> 00:30:26,810
 Ini selalu masalah kanonik, benar. 

703
00:30:26,810 --> 00:30:28,360
 Jadi seperti apa jika seseorang melakukan ini? 

704
00:30:28,360 --> 00:30:29,377
 Jadi itu tepat sekali. 

705
00:30:29,377 --> 00:30:31,960
 Jadi ini agak mirip dengan apa yang terjadi pada serangan BROP 

706
00:30:31,960 --> 00:30:35,290
 di mana, pada dasarnya kami telah mengatur secara acak di mana lokasi berada, 

707
00:30:35,290 --> 00:30:37,270
 tapi penyerang bisa melakukan pemeriksaan, benar. 

708
00:30:37,270 --> 00:30:38,760
 Dan cari tahu apa yang terjadi. 

709
00:30:38,760 --> 00:30:41,610
 Jadi Anda bisa membayangkan juga bahwa misalnya, jika penyerang tahu 

710
00:30:41,610 --> 00:30:44,410
 beberapa sub-urutan kode yang dia harapkan 

711
00:30:44,410 --> 00:30:46,220
 berada di biner, Anda bisa bayangkan 

712
00:30:46,220 --> 00:30:49,047
 hanya semacam mencoba xor biner dengan kode yang dikenal itu, 

713
00:30:49,047 --> 00:30:50,130
 mencoba untuk mengekstrak kunci. 

714
00:30:50,130 --> 00:30:51,630
 Dan ada banyak kejahatan di dunia, 

715
00:30:51,630 --> 00:30:53,890
 jadi kamu benar tentang itu. 

716
00:30:53,890 --> 00:30:55,720
 OK jadi itu intinya diskusi 

717
00:30:55,720 --> 00:31:00,310
 dari semua serangan pengacakan yang ingin saya diskusikan hari ini. 

718
00:31:00,310 --> 00:31:02,150
 Jadi satu hal yang perlu dibicarakan sebelum kita 

719
00:31:02,150 --> 00:31:04,370
 mendapatkan beberapa hal pemrograman berorientasi kembali, 

720
00:31:04,370 --> 00:31:06,370
 Anda mungkin bertanya-tanya yang mana dari pertahanan ini 

721
00:31:06,370 --> 00:31:08,440
 sebenarnya digunakan dalam praktek. 

722
00:31:08,440 --> 00:31:12,420
 Dan ternyata, baik GCC dan Visual Studio, 

723
00:31:12,420 --> 00:31:15,640
 mereka berdua mengaktifkan stack canaries secara default, benar. 

724
00:31:15,640 --> 00:31:19,900
 Jadi itu sangat populer, itu adalah komunitas yang sangat terkenal. 

725
00:31:19,900 --> 00:31:21,820
 Jika Anda melihat Linux dan Windows mereka 

726
00:31:21,820 --> 00:31:24,071
 juga dapat melakukan hal-hal seperti memori yang tidak dapat dieksekusi. 

727
00:31:24,071 --> 00:31:26,570
 Mereka juga dapat melakukan hal-hal seperti mengacak ruang alamat, jadi 

728
00:31:26,570 --> 00:31:27,950
 itu juga [TIDAK JELAS]. 

729
00:31:27,950 --> 00:31:30,247
 Namun, hal-hal yang longgar itu tidak begitu populer. 

730
00:31:30,247 --> 00:31:31,955
 Dan itu karena beberapa biaya ini 

731
00:31:31,955 --> 00:31:33,621
 yang kita bicarakan di sini, dalam istilah 

732
00:31:33,621 --> 00:31:36,925
 overhead memori, CPU, alarm palsu, dan seterusnya ans 

733
00:31:36,925 --> 00:31:38,560
 sebagainya. 

734
00:31:38,560 --> 00:31:41,810
 Jadi itu pada dasarnya survei tentang seni, 

735
00:31:41,810 --> 00:31:45,970
 dalam mencoba untuk mencegah buffer overflows ini. 

736
00:31:45,970 --> 00:31:50,311
 Jadi sekarang kita akan berbicara tentang pemograman yang berorientasi kembali ini 

737
00:31:50,311 --> 00:31:50,810
 barang. 

738
00:31:50,810 --> 00:31:53,900


739
00:31:53,900 --> 00:31:56,050
 Jadi apa yang saya jelaskan untuk Anda sejauh ini hari ini 

740
00:31:56,050 --> 00:31:58,260
 pengacakan ruang alamat dan data 

741
00:31:58,260 --> 00:32:01,264
 pencegahan eksekusi, itulah ... 

742
00:32:01,264 --> 00:32:03,180
 baca, tulis, dan jalankan yang baru saya jelaskan. 

743
00:32:03,180 --> 00:32:05,662
 Hal-hal itu sebenarnya sangat, sangat kuat, benar. 

744
00:32:05,662 --> 00:32:07,620
 Karena pengacakan mencegah penyerang 

745
00:32:07,620 --> 00:32:10,036
 dari benar-benar memahami di mana alamat berkode keras kami 

746
00:32:10,036 --> 00:32:10,580
 adalah. 

747
00:32:10,580 --> 00:32:11,980
 Dan pencegahan eksekusi data 

748
00:32:11,980 --> 00:32:15,198
 mengatakan, bahkan jika Anda dapat memasukkan kode shell ke dalam tumpukan, 

749
00:32:15,198 --> 00:32:16,823
 maka penyerang tidak bisa langsung melompat ke sana 

750
00:32:16,823 --> 00:32:18,160
 dan jalankan, benar. 

751
00:32:18,160 --> 00:32:19,560
 Jadi di ruangnya, itu seperti, 

752
00:32:19,560 --> 00:32:21,226
 Anda benar-benar telah membuat banyak kemajuan 

753
00:32:21,226 --> 00:32:25,469
 untuk menghentikan penyerang ini, tapi tentu saja di sana 

754
00:32:25,469 --> 00:32:28,010
 apakah para peretas ini ada di luar sana yang menghabiskan waktu untuk berpikir 

755
00:32:28,010 --> 00:32:29,560
 tentang bagaimana menghancurkan hidup kita. 

756
00:32:29,560 --> 00:32:33,030
 Jadi apa wawasan di balik pemrograman yang berorientasi laba? 

757
00:32:33,030 --> 00:32:35,830
 Wawasannya adalah itu, bagaimana jika bukan penyerang 

758
00:32:35,830 --> 00:32:39,660
 mampu menghasilkan kode baru pada saat menyerang, apa 

759
00:32:39,660 --> 00:32:42,430
 jika penyerang bisa string bersama-sama sudah ada sebelumnya 

760
00:32:42,430 --> 00:32:47,050
 potongan kode dan kemudian string mereka bersama-sama dengan cara menyimpang, 

761
00:32:47,050 --> 00:32:47,550
 kanan? 

762
00:32:47,550 --> 00:32:50,281
 Dan kita tahu bahwa program itu sudah memuat banyak kode, 

763
00:32:50,281 --> 00:32:50,780
 kanan. 

764
00:32:50,780 --> 00:32:53,508
 Jadi mudah-mudahan, atau tidak menyenangkan, tergantung pada sisi mana ini 

765
00:32:53,508 --> 00:32:54,450
 Anda berada di. 

766
00:32:54,450 --> 00:32:56,900
 Jika Anda dapat menemukan cuplikan kode yang cukup menarik, 

767
00:32:56,900 --> 00:32:59,800
 Anda dapat merangkainya bersama untuk membentuk dasarnya 

768
00:32:59,800 --> 00:33:01,630
 seperti bahasa lengkap Turing ini, di mana 

769
00:33:01,630 --> 00:33:03,540
 penyerang pada dasarnya dapat melakukan apa pun yang diinginkan penyerang 

770
00:33:03,540 --> 00:33:04,140
 melakukan. 

771
00:33:04,140 --> 00:33:07,240
 Jadi itulah wawasan di balik pemrograman yang berorientasi laba. 

772
00:33:07,240 --> 00:33:08,980
 Jadi, pahamilah cara kerjanya. 

773
00:33:08,980 --> 00:33:11,600
 Mari kita lihat contoh yang sangat sederhana yang akan terjadi pada awalnya 

774
00:33:11,600 --> 00:33:14,800
 memulai sangat akrab, kan. 

775
00:33:14,800 --> 00:33:19,210
 Tapi kemudian itu sangat cepat akan turun ke kegilaan. 

776
00:33:19,210 --> 00:33:23,560
 Jadi katakanlah kita memiliki program berikut. 

777
00:33:23,560 --> 00:33:29,810
 Jadi kami memiliki beberapa program-- maaf, beberapa fungsi dan nyaman 

778
00:33:29,810 --> 00:33:33,770
 untuk penyerang, ia memiliki fungsi yang bagus di sini disebut 

779
00:33:33,770 --> 00:33:36,300
 jalankan shell. 

780
00:33:36,300 --> 00:33:38,790
 Jadi ini hanya akan memanggil sistem, 

781
00:33:38,790 --> 00:33:45,830
 itu akan mengeksekusi bin slash bash dan kemudian dilakukan. 

782
00:33:45,830 --> 00:33:51,280
 Dan kemudian kami mendapat proses buffer overflow kanonik 

783
00:33:51,280 --> 00:33:56,040
 atau maaf, berfungsi di sini, pada dasarnya hal ini 

784
00:33:56,040 --> 00:34:01,940
 akan mendeklarasikan buffer, dan kemudian itu 

785
00:34:01,940 --> 00:34:07,370
 akan menggunakan salah satu fungsi tidak aman ini 

786
00:34:07,370 --> 00:34:12,870
 untuk mengisi byte di buffer. 

787
00:34:12,870 --> 00:34:17,210
 Oke, kita tahu ini bisa meluap, oke, 

788
00:34:17,210 --> 00:34:18,510
 ini adalah berita lama. 

789
00:34:18,510 --> 00:34:22,969
 Sekarang yang menarik adalah kita memiliki fungsi ini di sini, 

790
00:34:22,969 --> 00:34:26,110
 jalankan shell, tetapi tampaknya tidak cukup 

791
00:34:26,110 --> 00:34:29,900
 untuk diakses dengan beberapa cara langsung berdasarkan buffer ini 

792
00:34:29,900 --> 00:34:30,400
 meluap. 

793
00:34:30,400 --> 00:34:35,540
 Jadi bagaimana penyerang dapat menjalankan perintah shell run ini di sini? 

794
00:34:35,540 --> 00:34:38,550
 Serangan itu mungkin melakukan beberapa hal. 

795
00:34:38,550 --> 00:34:42,920
 Jadi pertama-tama, penyerang dapat membongkar programnya, 

796
00:34:42,920 --> 00:34:46,699
 jalankan GDB, cari tahu alamat dari hal ini di eksekusi, 

797
00:34:46,699 --> 00:34:47,199
 kanan. 

798
00:34:47,199 --> 00:34:48,900
 Jadi Anda semua harus sangat akrab dengan melakukan hal semacam itu 

799
00:34:48,900 --> 00:34:50,208
 hal melalui lab. 

800
00:34:50,208 --> 00:34:51,999
 Itu hal pertama yang bisa dilakukan penyerang. 

801
00:34:52,000 --> 00:34:54,480
 Dan kemudian selama buffer overflow, 

802
00:34:54,480 --> 00:34:57,410
 penyerang pada dasarnya dapat mengambil alamat itu, 

803
00:34:57,410 --> 00:35:00,360
 letakkan di buffer overflow yang dihasilkan 

804
00:35:00,360 --> 00:35:04,450
 dan pastikan bahwa fungsi kembali menjalankan shell. 

805
00:35:04,450 --> 00:35:09,370
 Jadi hanya untuk membuatnya jelas, mari gambar di sini. 

806
00:35:09,370 --> 00:35:14,060
 Jadi, Anda memiliki pengaturan yang terlihat 

807
00:35:14,060 --> 00:35:20,541
 seperti ini di bagian bawah, kita punya buffer, 

808
00:35:20,541 --> 00:35:21,540
 itu sedang meluap. 

809
00:35:21,540 --> 00:35:26,340


810
00:35:26,340 --> 00:35:36,590
 Dan kemudian di sini, kita memiliki save the break pointer, 

811
00:35:36,590 --> 00:35:44,395
 di sini kami memiliki alamat pengirim, untuk pesan proses. 

812
00:35:44,395 --> 00:35:48,990


813
00:35:48,990 --> 00:35:54,850
 Jadi ingat bahwa penunjuk tumpukan baru akan berada di sini pada awalnya, 

814
00:35:54,850 --> 00:35:57,350
 ketika kita mulai menjalankan fungsi. 

815
00:35:57,350 --> 00:36:07,710
 Ini adalah penembak jeda baru, ini 

816
00:36:07,710 --> 00:36:10,740
 adalah apa yang penunjuk tumpukan dulu. 

817
00:36:10,740 --> 00:36:13,980


818
00:36:13,980 --> 00:36:19,390
 Lalu kita punya beberapa penunjuk di sini, 

819
00:36:19,390 --> 00:36:20,430
 untuk frame sebelumnya. 

820
00:36:20,430 --> 00:36:25,390


821
00:36:25,390 --> 00:36:27,940
 Oke, jadi ini seharusnya terlihat akrab. 

822
00:36:27,940 --> 00:36:29,790
 Jadi pada dasarnya, dalam serangan itu, seperti yang saya katakan, 

823
00:36:29,790 --> 00:36:31,830
 kami telah menggunakan GDB untuk mencari tahu apa 

824
00:36:31,830 --> 00:36:33,220
 alamatnya adalah shell run. 

825
00:36:33,220 --> 00:36:37,360
 Jadi di buffer overflow, kita pada dasarnya bisa saja 

826
00:36:37,360 --> 00:36:44,140
 letakkan alamat run shell di sini, kan. 

827
00:36:44,140 --> 00:36:46,390
 Jadi ini adalah ekstensi yang cukup sederhana 

828
00:36:46,390 --> 00:36:48,240
 dari apa yang sudah kita ketahui cara melakukannya, benar. 

829
00:36:48,240 --> 00:36:50,270
 Jadi pada dasarnya itu mengatakan, jika kita nyaman 

830
00:36:50,270 --> 00:36:52,337
 memiliki perintah yang menjalankan cangkang, 

831
00:36:52,337 --> 00:36:54,170
 jika kita bisa membongkar biner, cari tahu 

832
00:36:54,170 --> 00:36:57,010
 di mana alamat itu, kita bisa menempatkan itu di luapan ini 

833
00:36:57,010 --> 00:36:58,422
 larik yang kita miliki di sini. 

834
00:36:58,422 --> 00:37:00,130
 Jadi itu seharusnya cukup mudah. 

835
00:37:00,130 --> 00:37:02,700
 Apakah itu masuk akal? 

836
00:37:02,700 --> 00:37:03,490
 BAIK. 

837
00:37:03,490 --> 00:37:07,390
 Jadi, ini adalah contoh yang sangat kekanak-kanakan, 

838
00:37:07,390 --> 00:37:09,690
 karena programmer untuk beberapa alasan gila 

839
00:37:09,690 --> 00:37:12,030
 telah menempatkan buah gantung rendah ini di sini. 

840
00:37:12,030 --> 00:37:14,670
 Jadi sebagai penyerang ini seperti Natal datang lebih awal, kan. 

841
00:37:14,670 --> 00:37:17,620
 Sekarang mungkin bukan kasus Anda memiliki sesuatu 

842
00:37:17,620 --> 00:37:19,420
 semenyenangkan ini. 

843
00:37:19,420 --> 00:37:25,400
 Jadi apa yang bisa Anda miliki, adalah sesuatu seperti ini. 

844
00:37:25,400 --> 00:37:29,840
 Jadi mari kita katakan bahwa alih-alih hal ini dipanggil 

845
00:37:29,840 --> 00:37:33,810
 jalankan shell, kami menyebutnya run boring dan kemudian 

846
00:37:33,810 --> 00:37:41,880
 mungkin hal ini hanya mengeksekusi bin slash OS katakanlah. 

847
00:37:41,880 --> 00:37:47,480
 Tapi mari kita katakan bahwa semuanya tidak sepenuhnya hilang, 

848
00:37:47,480 --> 00:37:51,730
 karena kami benar-benar memiliki tali di sini 

849
00:37:51,730 --> 00:37:56,365
 yang dengan mudah memberi kita jalan itu. 

850
00:37:56,365 --> 00:38:04,700


851
00:38:04,700 --> 00:38:08,810
 Jadi yang menarik tentang ini adalah, kita bisa membongkar 

852
00:38:08,810 --> 00:38:11,570
 program, cari lokasi yang membosankan, 

853
00:38:11,570 --> 00:38:13,380
 tetapi sebagai penyerang, yang ingin menjalankan OS? 

854
00:38:13,380 --> 00:38:15,860
 Benar, itu tidak menyenangkan Tapi kita benar-benar 

855
00:38:15,860 --> 00:38:21,910
 memiliki string dalam memori yang mengarah ke jalan shell 

856
00:38:21,910 --> 00:38:24,660
 dan sebenarnya kami juga tahu sesuatu yang menarik juga. 

857
00:38:24,660 --> 00:38:27,440
 Yaitu bahwa meskipun program tidak memanggil sistem 

858
00:38:27,440 --> 00:38:30,830
 dengan argumen yang kita inginkan, itu memanggil sistem entah bagaimana. 

859
00:38:30,830 --> 00:38:32,700
 Jadi kita tahu bahwa sistem harus mendapatkan 

860
00:38:32,700 --> 00:38:35,860
 terkait dengan program ini, entah bagaimana. 

861
00:38:35,860 --> 00:38:38,630
 Jadi kita benar-benar dapat memanfaatkan kedua hal itu, 

862
00:38:38,630 --> 00:38:42,700
 untuk benar-benar memanggil sistem dengan argumen ini di sini. 

863
00:38:42,700 --> 00:38:45,610
 Jadi hal pertama yang kita lakukan, adalah kita bisa masuk GDB 

864
00:38:45,610 --> 00:38:48,460
 dan kita bisa mencari tahu di mana 

865
00:38:48,460 --> 00:38:52,634
 Hal ini terletak pada proses gambar biner, kan. 

866
00:38:52,634 --> 00:38:55,050
 Jadi Anda hanya pergi ke GDB, ketik saja pada dasarnya sistem cetak 

867
00:38:55,050 --> 00:38:56,070
 dan saya akan memberi Anda beberapa informasi 

868
00:38:56,070 --> 00:38:57,335
 tentang offset yang OK. 

869
00:38:57,335 --> 00:38:58,710
 Jadi itu cukup mudah. 

870
00:38:58,710 --> 00:39:00,989
 Anda juga bisa melakukan hal yang sama dengan bash path. 

871
00:39:00,989 --> 00:39:02,530
 Benar, Anda hanya menggunakan GDB untuk mencari tahu 

872
00:39:02,530 --> 00:39:03,500
 di mana benda ini hidup. 

873
00:39:03,500 --> 00:39:05,125
 Ini string yang dinyatakan statis, benar. 

874
00:39:05,125 --> 00:39:07,140
 Jadi, Anda akan dapat menemukan tempat tinggal itu. 

875
00:39:07,140 --> 00:39:09,357
 Dan begitu Anda selesai melakukannya, sekarang Anda 

876
00:39:09,357 --> 00:39:11,440
 harus melakukan sesuatu yang sedikit berbeda, benar. 

877
00:39:11,440 --> 00:39:14,510
 Karena sekarang kita harus mencari tahu, 

878
00:39:14,510 --> 00:39:18,160
 cara memanggil sistem dengan argumen pilihan kita, 

879
00:39:18,160 --> 00:39:18,660
 kanan. 

880
00:39:18,660 --> 00:39:21,750
 Dan cara kami melakukannya adalah dengan berpura-pura 

881
00:39:21,750 --> 00:39:24,730
 bingkai panggilan untuk sistem. 

882
00:39:24,730 --> 00:39:26,490
 OK, jadi ingat bahwa bingkai adalah benda 

883
00:39:26,490 --> 00:39:28,240
 bahwa kompilator dan perangkat keras 

884
00:39:28,240 --> 00:39:31,361
 bekerja sama untuk menggunakan untuk mengimplementasikan tumpukan panggilan, 

885
00:39:31,361 --> 00:39:31,860
 kanan. 

886
00:39:31,860 --> 00:39:35,450
 Jadi, inilah dasarnya yang ingin kita lakukan. 

887
00:39:35,450 --> 00:39:38,630


888
00:39:38,630 --> 00:39:50,710
 Kami ingin menyiapkan sesuatu seperti ini di tumpukan, kan. 

889
00:39:50,710 --> 00:39:53,630
 Jadi pada dasarnya kita akan memalsukan apa 

890
00:39:53,630 --> 00:39:58,700
 sistem akan berharap berada di tumpukan, 

891
00:39:58,700 --> 00:40:01,480
 tetapi tepat sebelum benar-benar mengeksekusi kode. 

892
00:40:01,480 --> 00:40:05,800


893
00:40:05,800 --> 00:40:07,860
 Jadi di sini kita memiliki argumen sistem, 

894
00:40:07,860 --> 00:40:10,580
 ini adalah string yang sebenarnya ingin kita jalankan. 

895
00:40:10,580 --> 00:40:19,160
 Dan kemudian di sini, di sinilah sistem harus kembali, 

896
00:40:19,160 --> 00:40:19,790
 setelah selesai. 

897
00:40:19,790 --> 00:40:23,530


898
00:40:23,530 --> 00:40:27,690
 Benar, jadi ini adalah sistem apa yang mengharapkan tumpukan terlihat seperti, 

899
00:40:27,690 --> 00:40:29,067
 tepat sebelum dimulai eksekusi. 

900
00:40:29,067 --> 00:40:31,650
 Ini akan mengatakan ini adalah di mana saya harus pergi ketika saya selesai, 

901
00:40:31,650 --> 00:40:34,180
 ini adalah hal yang harus saya konsumsi sebagai argumen saya, benar. 

902
00:40:34,180 --> 00:40:35,380
 Di masa lalu kita sudah mengasumsikan itu di sana 

903
00:40:35,380 --> 00:40:36,670
 tidak ada argumen ketika Anda melewati fungsi, 

904
00:40:36,670 --> 00:40:38,420
 tetapi sekarang ini sedikit berbeda, benar. 

905
00:40:38,420 --> 00:40:39,878
 Jadi pada dasarnya kita harus memastikan 

906
00:40:39,878 --> 00:40:44,280
 bahwa hal ini dalam kode luapan yang kita buat, 

907
00:40:44,280 --> 00:40:44,780
 kanan. 

908
00:40:44,780 --> 00:40:47,280
 Kami hanya harus memastikan panggilan palsu ini 

909
00:40:47,280 --> 00:40:50,280
 bingkai dalam array itu. 

910
00:40:50,280 --> 00:40:53,640
 Jadi pada dasarnya cara ini akan berhasil 

911
00:40:53,640 --> 00:40:55,615
 adalah, kami akan melakukan hal berikut. 

912
00:40:55,615 --> 00:40:59,810


913
00:40:59,810 --> 00:41:02,640
 Jadi sekali lagi ingat luapan naik di sini. 

914
00:41:02,640 --> 00:41:08,590
 Jadi pertama, kita akan memasukkan alamat sistem di sini. 

915
00:41:08,590 --> 00:41:15,370


916
00:41:15,370 --> 00:41:20,781
 Dan kemudian di sini, kita akan menempatkan kembali sampah 

917
00:41:20,781 --> 00:41:21,280
 alamat. 

918
00:41:21,280 --> 00:41:24,622


919
00:41:24,622 --> 00:41:26,080
 Benar, di sinilah sistem berjalan 

920
00:41:26,080 --> 00:41:27,414
 untuk kembali setelah selesai. 

921
00:41:27,414 --> 00:41:28,830
 Untuk keperluan diskusi 

922
00:41:28,830 --> 00:41:30,246
 sekarang, kami tidak peduli apa yang dilakukannya, 

923
00:41:30,246 --> 00:41:33,020
 kami hanya akan membuat ini hanya beberapa set byte acak. 

924
00:41:33,020 --> 00:41:36,060
 Dan kemudian di sini, kita benar-benar pergi 

925
00:41:36,060 --> 00:41:46,674
 untuk menempatkan alamat bash path, kan. 

926
00:41:46,674 --> 00:41:48,090
 Jadi apa yang akan terjadi sekarang kapan 

927
00:41:48,090 --> 00:41:49,620
 kami melakukan buffer ini dalam limpahan? 

928
00:41:49,620 --> 00:41:52,690
 Jadi apa yang akan terjadi adalah, pesan proses sedang berjalan 

929
00:41:52,690 --> 00:41:54,740
 untuk menyelesaikan, itu akan berkata, oke, hei, 

930
00:41:54,740 --> 00:41:56,750
 di sinilah aku harus kembali, benar. 

931
00:41:56,750 --> 00:42:00,070
 Dan kemudian akan muncul tumpukan, benar, 

932
00:42:00,070 --> 00:42:03,140
 dan sekarang kode sistem sedang dijalankan, benar. 

933
00:42:03,140 --> 00:42:06,610
 Kode sistem sekarang melihat bingkai panggilan palsu itu 

934
00:42:06,610 --> 00:42:08,190
 yang kami buat, benar. 

935
00:42:08,190 --> 00:42:10,310
 Sejauh menyangkut sistem, tidak ada yang aneh 

936
00:42:10,310 --> 00:42:11,750
 telah terjadi, benar. 

937
00:42:11,750 --> 00:42:13,840
 Sistem akan mengatakan, aha inilah argumennya 

938
00:42:13,840 --> 00:42:16,950
 yang ingin saya laksanakan, itu bin slash bash, 

939
00:42:16,950 --> 00:42:19,460
 itu akan mengeksekusi dan voila, penyerang 

940
00:42:19,460 --> 00:42:22,550
 memiliki cangkang, benar. 

941
00:42:22,550 --> 00:42:23,550
 Jadi ini masuk akal? 

942
00:42:23,550 --> 00:42:25,300
 Jadi pada dasarnya apa yang kami lakukan adalah, kita sekarang 

943
00:42:25,300 --> 00:42:27,610
 memanfaatkan pengetahuan konvensi pemanggilan, 

944
00:42:27,610 --> 00:42:30,610
 untuk platform untuk membuat frame tumpukan palsu, 

945
00:42:30,610 --> 00:42:32,110
 atau bingkai panggilan palsu yang harus saya katakan. 

946
00:42:32,110 --> 00:42:34,680
 Dan menggunakan bingkai panggilan palsu itu, 

947
00:42:34,680 --> 00:42:38,575
 kita benar-benar dapat menjalankan fungsi apa pun yang sudah ditautkan 

948
00:42:38,575 --> 00:42:42,330
 dan ditentukan dalam aplikasi. 

949
00:42:42,330 --> 00:42:45,150
 Apakah itu masuk akal? 

950
00:42:45,150 --> 00:42:52,050
 Oke, pertanyaan lain yang mungkin Anda miliki adalah, 

951
00:42:52,050 --> 00:42:57,111
 bagaimana jika string ini tidak benar-benar ada dalam program? 

952
00:42:57,111 --> 00:42:59,110
 Sekarang harus jelas, string ini hampir pasti 

953
00:42:59,110 --> 00:43:00,192
 dalam program. 

954
00:43:00,192 --> 00:43:01,900
 Jadi itu satu hal lucu tentang keamanan, 

955
00:43:01,900 --> 00:43:04,285
 hanya ada semua jenis string menyenangkan yang diletakkan di sekitar, 

956
00:43:04,285 --> 00:43:05,400
 Anda bisa pergi ke kota sepanjang hari. 

957
00:43:05,400 --> 00:43:07,610
 Nah misalkan kita hidup di dunia bizarro 

958
00:43:07,610 --> 00:43:09,550
 dan seperti string ini tidak ada dalam program. 

959
00:43:09,550 --> 00:43:11,220
 Jadi apakah ada yang punya ide tentang apa 

960
00:43:11,220 --> 00:43:13,387
 kita bisa lakukan agar string itu ada di program? 

961
00:43:13,387 --> 00:43:15,511
 AUDIENCE: Kita dapat menempatkan string pada [TIDAK JELAS]. 

962
00:43:15,511 --> 00:43:17,450
 PROFESOR; Ya persis, jangan percaya pria itu. 

963
00:43:17,450 --> 00:43:18,783
 Itu yang bisa kamu lakukan, tepatnya. 

964
00:43:18,783 --> 00:43:23,060
 Jadi, apa yang dapat Anda lakukan sebenarnya untuk di sini, 

965
00:43:23,060 --> 00:43:29,990
 memiliki alamat bash path, sebenarnya arahkan ke sini, benar. 

966
00:43:29,990 --> 00:43:35,890
 Dan kemudian Anda akan menempatkan - di sini Anda akan menempatkan slash BIN 

967
00:43:35,890 --> 00:43:41,860
 garis miring slash 0. 

968
00:43:41,860 --> 00:43:43,470
 Jadi begitulah cara Anda bisa berkeliling-- saya 

969
00:43:43,470 --> 00:43:45,720
 pikir saya benar matematika itu, karena masing-masing ini 

970
00:43:45,720 --> 00:43:48,360
 adalah 4 byte. 

971
00:43:48,360 --> 00:43:51,710
 Tapi bagaimanapun, jadi Anda memiliki pointer naik di sini dan kemudian 

972
00:43:51,710 --> 00:43:52,730
 booming, selesai. 

973
00:43:52,730 --> 00:43:55,890
 Jadi sekarang Anda benar-benar dapat memunculkan argumen 

974
00:43:55,890 --> 00:43:58,130
 hanya dengan memasukkannya ke dalam kode shell. 

975
00:43:58,130 --> 00:44:00,690


976
00:44:00,690 --> 00:44:02,370
 Sangat mengerikan. 

977
00:44:02,370 --> 00:44:07,301
 Jadi ini semua membangun menuju serangan BROP penuh, 

978
00:44:07,301 --> 00:44:07,800
 kanan. 

979
00:44:07,800 --> 00:44:09,380
 Tetapi sebelum Anda dapat menyebutkan serangan BROP penuh, 

980
00:44:09,380 --> 00:44:10,921
 Anda harus memahami bagaimana Anda adil 

981
00:44:10,921 --> 00:44:13,560
 rantai bersama hal-hal yang sudah ada sebelumnya dalam kode. 

982
00:44:13,560 --> 00:44:16,950


983
00:44:16,950 --> 00:44:20,300
 Jadi satu hal yang perlu diperhatikan adalah ketika saya mengatur pengembalian ini 

984
00:44:20,300 --> 00:44:23,170
 alamat di sini, saya hanya berkata, eh hanya menaruh beberapa sampah di sini, 

985
00:44:23,170 --> 00:44:25,740
 itu tidak terlalu penting, kami hanya ingin mendapatkan cangkang. 

986
00:44:25,740 --> 00:44:28,770
 Tetapi jika Anda penyerang, Anda sebenarnya bisa 

987
00:44:28,770 --> 00:44:30,420
 atur kembali alamat ini ke sesuatu 

988
00:44:30,420 --> 00:44:32,500
 itu sebenarnya berguna, benar. 

989
00:44:32,500 --> 00:44:35,970
 Dan jika Anda melakukan itu, Anda bisa benar-benar bersatu 

990
00:44:35,970 --> 00:44:39,810
 beberapa fungsi, beberapa indikasi fungsi berturut-turut, 

991
00:44:39,810 --> 00:44:40,310
 kanan. 

992
00:44:40,310 --> 00:44:42,590
 Itu sebenarnya sangat, sangat kuat, benar. 

993
00:44:42,590 --> 00:44:44,830
 Karena secara khusus, jika kita benar-benar adil 

994
00:44:44,830 --> 00:44:47,364
 atur kembali alamat ini untuk melompat, saya 

995
00:44:47,364 --> 00:44:49,030
 maksudnya mungkin bahwa ketika kita mengambilnya kembali, 

996
00:44:49,030 --> 00:44:51,410
 seperti program macet, mungkin kita tidak menginginkan itu, 

997
00:44:51,410 --> 00:44:51,740
 kanan. 

998
00:44:51,740 --> 00:44:53,865
 Jadi sebenarnya dapat mulai merantai beberapa hal ini 

999
00:44:53,865 --> 00:44:55,980
 untuk melakukan hal-hal yang menarik. 

1000
00:44:55,980 --> 00:45:01,370
 Jadi katakanlah bahwa tujuan kita adalah kita ingin memanggil sistem 

1001
00:45:01,370 --> 00:45:03,309
 sejumlah kali acak. 

1002
00:45:03,309 --> 00:45:04,850
 Kami tidak hanya ingin melakukannya sekali saja, 

1003
00:45:04,850 --> 00:45:06,766
 kita akan melakukannya beberapa kali secara acak. 

1004
00:45:06,766 --> 00:45:08,037
 Jadi bagaimana kita bisa melakukan itu? 

1005
00:45:08,037 --> 00:45:10,120
 Kami akan menggunakan dua informasi 

1006
00:45:10,120 --> 00:45:11,460
 bahwa kita sudah tahu cara mendapatkannya, benar. 

1007
00:45:11,460 --> 00:45:13,820
 Kita sudah tahu cara mendapatkan alamat sistem, benar. 

1008
00:45:13,820 --> 00:45:16,090
 Kami hanya melihat GDB dan menemukannya. 

1009
00:45:16,090 --> 00:45:20,180
 Kami juga tahu cara menemukan alamat string itu, 

1010
00:45:20,180 --> 00:45:21,960
 bin flash bash. 

1011
00:45:21,960 --> 00:45:25,490
 Sekarang untuk benar-benar membuat serangan ini bekerja menggunakan banyak panggilan 

1012
00:45:25,490 --> 00:45:28,310
 ke sistem, kita harus menggunakan gadget, benar. 

1013
00:45:28,310 --> 00:45:29,820
 Ini semakin dekat dengan kita 

1014
00:45:29,820 --> 00:45:31,470
 terjadi di kertas BROP. 

1015
00:45:31,470 --> 00:45:34,210


1016
00:45:34,210 --> 00:45:37,660
 Jadi yang perlu kita lakukan sekarang adalah menemukan alamatnya 

1017
00:45:37,660 --> 00:45:41,670
 dari dua kode Op ini. 

1018
00:45:41,670 --> 00:45:48,070


1019
00:45:48,070 --> 00:45:51,490
 Benar, jadi apa ini, jadi ini pop di EAX, jadi apa 

1020
00:45:51,490 --> 00:45:52,110
 ini lakukan? 

1021
00:45:52,110 --> 00:45:58,050
 Ini hanya mengambil bagian atas tumpukan 

1022
00:45:58,050 --> 00:46:01,810
 dan kemudian dimasukkan ke dalam daftar EAX. 

1023
00:46:01,810 --> 00:46:03,910
 Dan apa instruksi ret yang akan dilakukan? 

1024
00:46:03,910 --> 00:46:07,980
 Itu hanya muncul di bagian atas tumpukan 

1025
00:46:07,980 --> 00:46:15,340
 dan kemudian memasukkannya ke EIP, penunjuk instruksi. 

1026
00:46:15,340 --> 00:46:18,060
 Oke, jadi ini yang dikenal sebagai gadget, benar. 

1027
00:46:18,060 --> 00:46:21,030
 Ini seperti seperangkat instruksi perakitan kecil 

1028
00:46:21,030 --> 00:46:24,790
 yang dapat digunakan penyerang untuk membuat ini lebih besar 

1029
00:46:24,790 --> 00:46:25,890
 serangan megah. 

1030
00:46:25,890 --> 00:46:30,410
 OK, Jadi bagaimana kita bisa menemukan gadget ini, benar. 

1031
00:46:30,410 --> 00:46:33,140
 Sebenarnya ada beberapa alat rak 

1032
00:46:33,140 --> 00:46:35,010
 yang digunakan peretas untuk menemukan hal-hal ini, 

1033
00:46:35,010 --> 00:46:36,776
 tidak sulit untuk mendapatkan binari, kan. 

1034
00:46:36,776 --> 00:46:38,150
 Pada dasarnya hanya melakukan [tidak terdengar] 

1035
00:46:38,150 --> 00:46:39,570
 untuk hal-hal semacam ini, benar. 

1036
00:46:39,570 --> 00:46:43,070
 Jadi sama mudahnya menemukan salah satu gadget ini, 

1037
00:46:43,070 --> 00:46:45,024
 dengan asumsi bahwa Anda punya salinan biner 

1038
00:46:45,024 --> 00:46:46,940
 dan kami belum khawatir tentang pengacakan. 

1039
00:46:46,940 --> 00:46:48,600
 Sangat mudah untuk menemukan hal-hal ini. 

1040
00:46:48,600 --> 00:46:50,377
 Sama seperti itu sangat mudah untuk menemukan alamat sistem dan barang 

1041
00:46:50,377 --> 00:46:51,420
 seperti itu. 

1042
00:46:51,420 --> 00:46:54,220
 Jadi jika kita punya salah satu gadget ini, 

1043
00:46:54,220 --> 00:46:56,020
 apa yang bisa kita gunakan untuk gadget ini? 

1044
00:46:56,020 --> 00:46:58,560
 Yah tentu saja jawabannya jahat. 

1045
00:46:58,560 --> 00:47:02,925
 Jadi, yang bisa kita lakukan adalah sebagai berikut. 

1046
00:47:02,925 --> 00:47:05,480


1047
00:47:05,480 --> 00:47:09,410
 Katakanlah kita mengubah tumpukan 

1048
00:47:09,410 --> 00:47:11,660
 sehingga terlihat seperti ini. 

1049
00:47:11,660 --> 00:47:19,500


1050
00:47:19,500 --> 00:47:22,470
 Jadi eksploitasi berjalan seperti ini. 

1051
00:47:22,470 --> 00:47:26,360
 Dan katakanlah, kita melakukan ini. 

1052
00:47:26,360 --> 00:47:28,310
 Jadi, hal pertama yang akan kita taruh di sini 

1053
00:47:28,310 --> 00:47:30,190
 adalah alamat sistem. 

1054
00:47:30,190 --> 00:47:32,960


1055
00:47:32,960 --> 00:47:35,380
 Dan hal yang akan kita pasang di sini, 

1056
00:47:35,380 --> 00:47:41,160
 adalah alamat gadget ret pop. 

1057
00:47:41,160 --> 00:47:45,750


1058
00:47:45,750 --> 00:47:58,180
 Kemudian di sini, kita akan menempatkan alamat bash path 

1059
00:47:58,180 --> 00:48:00,080
 dan kemudian kita akan mengulangi pola ini. 

1060
00:48:00,080 --> 00:48:10,620
 Jadi kita akan menempatkan alamat sistem, 

1061
00:48:10,620 --> 00:48:19,890
 alamat gadget ret pop, 

1062
00:48:19,890 --> 00:48:24,290
 dan kemudian alamat bash path. 

1063
00:48:24,290 --> 00:48:29,880


1064
00:48:29,880 --> 00:48:31,960
 Oke, jadi apa yang akan terjadi di sini sekarang? 

1065
00:48:31,960 --> 00:48:33,745
 Sekarang ini akan menjadi sedikit rumit, 

1066
00:48:33,745 --> 00:48:35,120
 dan catatan kuliah ini pergi 

1067
00:48:35,120 --> 00:48:36,490
 berada di web, jadi Anda mungkin saja 

1068
00:48:36,490 --> 00:48:38,060
 ingin mendengarkan apa yang terjadi, 

1069
00:48:38,060 --> 00:48:40,310
 tapi ini-- ketika aku pertama kali mengerti ini, ini 

1070
00:48:40,310 --> 00:48:42,850
 seperti memahami bahwa Sinterklas tidak benar. 

1071
00:48:42,850 --> 00:48:44,870
 Jadi apa yang akan terjadi adalah - dan omong-omong, 

1072
00:48:44,870 --> 00:48:47,411
 Sinterklas tidak nyata, kuharap aku tidak merusaknya untuk semua orang. 

1073
00:48:47,411 --> 00:48:48,530
 Jadi apa yang akan terjadi? 

1074
00:48:48,530 --> 00:48:50,760
 Jadi [INAUDIBLE] adalah apa yang menempatkan ini dalam memori. 

1075
00:48:50,760 --> 00:48:52,837
 Jadi kita akan mulai di sini, oke. 

1076
00:48:52,837 --> 00:48:53,920
 Jadi apa yang akan terjadi? 

1077
00:48:53,920 --> 00:48:57,075
 Kita akan kembali ke sistem, instruksi ret 

1078
00:48:57,075 --> 00:48:59,530
 akan mem-pop entri dari tumpukan, sekarang 

1079
00:48:59,530 --> 00:49:02,130
 bagian atas pointer stack di sini. 

1080
00:49:02,130 --> 00:49:06,510
 Oke, jadi sistem akan menemukan argumennya di sini, 

1081
00:49:06,510 --> 00:49:08,110
 itu akan mengeksekusi cangkangnya. 

1082
00:49:08,110 --> 00:49:11,490
 Maka itu akan selesai dan kembali ke apa pun 

1083
00:49:11,490 --> 00:49:13,070
 di sini, yang merupakan gadget pop. 

1084
00:49:13,070 --> 00:49:15,840
 Dalam mengeksekusi kembali itu, kita berubah 

1085
00:49:15,840 --> 00:49:17,770
 bagian atas penunjuk tumpukan berada di sini. 

1086
00:49:17,770 --> 00:49:20,770
 Oke, sekarang kita ada di gadget ret pop. 

1087
00:49:20,770 --> 00:49:23,190
 Oke, jadi apa itu gadget pop ret yang akan dilakukan? 

1088
00:49:23,190 --> 00:49:26,700
 Ini akan memunculkan apa yang ada di tumpukan, yang ini, OK. 

1089
00:49:26,700 --> 00:49:29,699
 Jadi sekarang bagian atas tumpukan ada di sini. 

1090
00:49:29,699 --> 00:49:31,240
 Lalu kita sekarang dalam instruksi ret 

1091
00:49:31,240 --> 00:49:32,730
 dari gadget ret pop. 

1092
00:49:32,730 --> 00:49:33,730
 Apa yang akan dilakukan ini? 

1093
00:49:33,730 --> 00:49:37,060
 Aha, ini akan memanggil sistem lagi, kan. 

1094
00:49:37,060 --> 00:49:41,400
 Jadi sekali lagi ret akan mem-pop ini dari tumpukan ini, 

1095
00:49:41,400 --> 00:49:42,690
 kita sekarang dalam sistem. 

1096
00:49:42,690 --> 00:49:44,644
 Bagian atas tumpukan ada di sini, sistem 

1097
00:49:44,644 --> 00:49:46,810
 akan - ini akan memicu frame panggilan, sistem. 

1098
00:49:46,810 --> 00:49:49,466
 Sistem mengambil argumen bash path di sini. 

1099
00:49:49,466 --> 00:49:52,681
 OK, dan kemudian akan ret, benar. 

1100
00:49:52,681 --> 00:49:53,980
 Di mana itu akan kembali? 

1101
00:49:53,980 --> 00:49:55,740
 Gadget ret pop lagi. 

1102
00:49:55,740 --> 00:49:57,977
 Jadi ret muncul tumpukan, kami 

1103
00:49:57,977 --> 00:50:00,850
 sekarang di gadget ret pop, gadget ret-- maaf, 

1104
00:50:00,850 --> 00:50:05,460
 gadget pop ret akan memunculkan ini, seterusnya dan seterusnya. 

1105
00:50:05,460 --> 00:50:06,050
 BAIK? 

1106
00:50:06,050 --> 00:50:08,760
 Jadi jelas kita bisa rantai urutan ini 

1107
00:50:08,760 --> 00:50:12,350
 untuk melaksanakan sejumlah hal yang sewenang-wenang, benar. 

1108
00:50:12,350 --> 00:50:15,380
 Dan ini pada intinya dimulai 

1109
00:50:15,380 --> 00:50:18,420
 untuk sampai ke inti dari apa yang berorientasi kembali pemrograman. 

1110
00:50:18,420 --> 00:50:23,060
 Perhatikan bahwa kami belum menjalankan apa pun di dalam tumpukan, benar. 

1111
00:50:23,060 --> 00:50:26,890
 Inilah yang telah memungkinkan kami untuk melampaui eksekusi data tersebut 

1112
00:50:26,890 --> 00:50:28,150
 bit pencegahan, benar. 

1113
00:50:28,150 --> 00:50:29,690
 Tidak ada yang dieksekusi di sini. 

1114
00:50:29,690 --> 00:50:33,150
 Kami hanya melompat ke hal-hal dengan cara yang tidak terduga 

1115
00:50:33,150 --> 00:50:35,300
 untuk melakukan apa yang ingin kita lakukan. 

1116
00:50:35,300 --> 00:50:39,350
 OK jadi ini sebenarnya sangat, sangat, sangat, pintar. 

1117
00:50:39,350 --> 00:50:41,620
 Dan yang menarik adalah pada level yang tinggi 

1118
00:50:41,620 --> 00:50:44,990
 Anda dapat berpikir tentang kami, kami sekarang telah mendefinisikan model baru ini 

1119
00:50:44,990 --> 00:50:46,180
 untuk perhitungan, benar. 

1120
00:50:46,180 --> 00:50:48,450
 Jadi dalam program tradisional yang tidak jahat, 

1121
00:50:48,450 --> 00:50:50,072
 Anda memiliki pointer instruksi itu 

1122
00:50:50,072 --> 00:50:52,030
 menunjukkan beberapa urutan instruksi linier. 

1123
00:50:52,030 --> 00:50:53,910
 Dan Anda menaikkan pointer instruksi 

1124
00:50:53,910 --> 00:50:56,030
 untuk mencari tahu apa yang harus dilakukan selanjutnya. 

1125
00:50:56,030 --> 00:50:58,720
 Intinya, apa yang dilakukan oleh pemrograman berorientasi pengembalian adalah, 

1126
00:50:58,720 --> 00:51:02,720
 ia menggunakan penunjuk tumpukan sebagai penunjuk instruksi. 

1127
00:51:02,720 --> 00:51:05,540
 Benar, jadi saat kita memindahkan penunjuk tumpukan, 

1128
00:51:05,540 --> 00:51:09,230
 kami menunjuk seperti blok kode lainnya 

1129
00:51:09,230 --> 00:51:10,720
 yang akan kita eksekusi. 

1130
00:51:10,720 --> 00:51:12,180
 Dan kemudian di ujung gadget, 

1131
00:51:12,180 --> 00:51:14,010
 Anda kembali ke penunjuk tumpukan 

1132
00:51:14,010 --> 00:51:16,218
 yang kemudian akan memberi tahu kami blok kode selanjutnya 

1133
00:51:16,218 --> 00:51:17,550
 untuk mengeksekusi. 

1134
00:51:17,550 --> 00:51:19,340
 Oke, apakah itu masuk akal? 

1135
00:51:19,340 --> 00:51:26,220


1136
00:51:26,220 --> 00:51:29,785
 Jadi pada dasarnya itulah bagaimana Anda dapat menghindari eksekusi data 

1137
00:51:29,785 --> 00:51:30,570
 hal pencegahan. 

1138
00:51:30,570 --> 00:51:32,190
 Begitulah cara Anda bisa mendapatkan 

1139
00:51:32,190 --> 00:51:36,170
 ini tidak mengeksekusi bit pada halaman. 

1140
00:51:36,170 --> 00:51:38,120
 Jadi hal berikutnya yang mungkin ingin kita lakukan 

1141
00:51:38,120 --> 00:51:39,710
 adalah kekalahan stack canaries. 

1142
00:51:39,710 --> 00:51:42,740
 Jadi jika Anda ingat, kenari ini adalah nilai ini 

1143
00:51:42,740 --> 00:51:45,510
 yang akan kami tempatkan di tumpukan itu, benar. 

1144
00:51:45,510 --> 00:51:48,620
 Jadi Anda bisa membayangkan burung kenari itu akan 

1145
00:51:48,620 --> 00:51:50,640
 pergi ke sini sebagai contoh, atau di sini, 

1146
00:51:50,640 --> 00:51:53,500
 dan itu akan mencegah seseorang mengesampingkan kembalinya 

1147
00:51:53,500 --> 00:51:56,370
 alamat, tanpa juga menimpa canary. 

1148
00:51:56,370 --> 00:52:00,350
 Dengan intuisi adalah bahwa sebelum sistem benar-benar 

1149
00:52:00,350 --> 00:52:02,330
 melompat ke alamat ret, dapat memeriksa 

1150
00:52:02,330 --> 00:52:04,890
 untuk melihat apakah kenari telah diubah 

1151
00:52:04,890 --> 00:52:07,380
 dengan cara yang salah. 

1152
00:52:07,380 --> 00:52:09,850
 Jadi begitulah cara kerja kenari, tapi bisakah kita 

1153
00:52:09,850 --> 00:52:11,060
 berkeliling kenari? 

1154
00:52:11,060 --> 00:52:13,250
 Bisakah kita menebak kenari entah bagaimana? 

1155
00:52:13,250 --> 00:52:17,950
 Sebenarnya kita bisa, jika kita membuat beberapa asumsi 

1156
00:52:17,950 --> 00:52:22,110
 tentang bagaimana sistem bekerja. 

1157
00:52:22,110 --> 00:52:31,650
 Jadi, bagaimana kita mengalahkan burung kenari itu? 

1158
00:52:31,650 --> 00:52:36,160


1159
00:52:36,160 --> 00:52:46,730
 Jadi hal pertama yang ingin kita asumsikan adalah, bahwa server, 

1160
00:52:46,730 --> 00:52:48,720
 itu harus memiliki kerentanan buffer overflow. 

1161
00:52:48,720 --> 00:52:53,420


1162
00:52:53,420 --> 00:52:58,140
 Hal kedua yang akan kita asumsikan, 

1163
00:52:58,140 --> 00:53:07,300
 adalah bahwa server akan crash dan merespons, hanya 

1164
00:53:07,300 --> 00:53:13,355
 restart, jika kita mengatur nilai canary ke yang buruk. 

1165
00:53:13,355 --> 00:53:19,600


1166
00:53:19,600 --> 00:53:22,060
 Dan hal ketiga yang akan kita asumsikan 

1167
00:53:22,060 --> 00:53:37,600
 adalah bahwa, setelah restart, bahwa kenari dan alamat apa pun 

1168
00:53:37,600 --> 00:53:42,695
 pengacakan ruang yang Anda lakukan, tidak dirandomisasi. 

1169
00:53:42,695 --> 00:53:49,184


1170
00:53:49,184 --> 00:53:50,850
 Benar, jadi apa artinya itu, kita 

1171
00:53:50,850 --> 00:53:53,520
 akan berasumsi bahwa jika kita entah bagaimana bisa merusak server, maka 

1172
00:53:53,520 --> 00:53:55,520
 ketika server restart, itu akan terjadi 

1173
00:53:55,520 --> 00:53:57,030
 nilai yang sama untuk canary. 

1174
00:53:57,030 --> 00:54:00,520
 Dan itu akan memiliki lokasi yang sama untuk semua kutipan 

1175
00:54:00,520 --> 00:54:04,030
 membongkar tumpukan informasi "acak", informasi heap dan kode 

1176
00:54:04,030 --> 00:54:05,140
 yang dimilikinya. 

1177
00:54:05,140 --> 00:54:08,622
 Jadi Anda mungkin bertanya-tanya mengapa ini terjadi? 

1178
00:54:08,622 --> 00:54:10,580
 Mengapa begitu ketika server kembali 

1179
00:54:10,580 --> 00:54:12,390
 tidak memiliki lokasi baru untuk hal-hal? 

1180
00:54:12,390 --> 00:54:14,020
 Alasannya karena banyak server 

1181
00:54:14,020 --> 00:54:17,950
 ditulis untuk menggunakan garpu, untuk membuat proses baru. 

1182
00:54:17,950 --> 00:54:20,260
 Dan jika Anda ingat, cagak sebenarnya 

1183
00:54:20,260 --> 00:54:23,580
 mewarisi - anak mewarisi alamat 

1184
00:54:23,580 --> 00:54:27,161
 ruang dari tata ruang alamat tepat dari orang tua, 

1185
00:54:27,161 --> 00:54:27,660
 kanan. 

1186
00:54:27,660 --> 00:54:30,890
 Ini adalah salinan di halaman tulis yang mengubah hal-hal sebagai anak 

1187
00:54:30,890 --> 00:54:33,510
 memperbarui hal-hal, tetapi jika Anda menggunakan garpu di sini, 

1188
00:54:33,510 --> 00:54:35,730
 bukannya mengeksekusi proses baru, 

1189
00:54:35,730 --> 00:54:39,680
 kapan pun proses server induk itu membentuk anak-anak baru, 

1190
00:54:39,680 --> 00:54:42,090
 anak-anak itu akan memiliki nilai kenari yang sama 

1191
00:54:42,090 --> 00:54:43,370
 di basis alamat, oke. 

1192
00:54:43,370 --> 00:54:44,995
 Jadi ini adalah asumsi bahwa kita 

1193
00:54:44,995 --> 00:54:49,000
 akan berusaha untuk mengalahkan burung kenari ini di sini. 

1194
00:54:49,000 --> 00:54:51,490
 Jadi bagaimana kita bisa mengalahkan kenari? 

1195
00:54:51,490 --> 00:54:54,680
 Serangannya sebenarnya cukup mudah. 

1196
00:54:54,680 --> 00:54:58,270
 Jadi bayangkan tumpukan itu naik dengan cara ini, benar. 

1197
00:54:58,270 --> 00:55:00,440
 Bayangkan Anda mendapat buffer overflow di sini, 

1198
00:55:00,440 --> 00:55:02,720
 kemudian bayangkan bahwa kenari ada di atas sini, benar. 

1199
00:55:02,720 --> 00:55:05,860
 Dan canary sebenarnya memiliki banyak byte, benar. 

1200
00:55:05,860 --> 00:55:07,850
 Jadi apa yang sebenarnya dapat Anda lakukan adalah, Anda 

1201
00:55:07,850 --> 00:55:12,280
 dapat menyelidiki byte tersebut satu demi satu dan mulai menebak nilainya 

1202
00:55:12,280 --> 00:55:13,740
 dari apa yang mereka byte, benar. 

1203
00:55:13,740 --> 00:55:20,940
 Jadi katakanlah itu - jadi burung kenari terlihat seperti ini. 

1204
00:55:20,940 --> 00:55:24,640
 Ini buffer yang melimpah, dan Anda mau 

1205
00:55:24,640 --> 00:55:26,200
 untuk menebak apa yang byte ini. 

1206
00:55:26,200 --> 00:55:28,290
 Jadi, hal pertama yang Anda tebak 

1207
00:55:28,290 --> 00:55:31,066
 apakah Anda mengambil overflow Anda, hanya untuk byte pertama ini 

1208
00:55:31,066 --> 00:55:34,910
 dari kenari dan Anda katakan, hei, apakah itu byte 0? 

1209
00:55:34,910 --> 00:55:36,806
 Anda menulis 0 di sana, dengan luapan Anda. 

1210
00:55:36,806 --> 00:55:38,556
 Anda benar atau Anda salah. 

1211
00:55:38,556 --> 00:55:43,000
 Jika Anda salah, maka server akan crash, kan. 

1212
00:55:43,000 --> 00:55:45,560
 Jika Anda benar Anda katakan, aha saya sebenarnya 

1213
00:55:45,560 --> 00:55:48,020
 tahu byte pertama dari kenari sekarang, kan. 

1214
00:55:48,020 --> 00:55:49,400
 Maka Anda mulai menebak di sini. 

1215
00:55:49,400 --> 00:55:51,710
 Anda berkata, apakah Anda 0? 

1216
00:55:51,710 --> 00:55:53,300
 Mungkin tidak, itu akan crash. 

1217
00:55:53,300 --> 00:55:54,180
 Apakah kamu satu? 

1218
00:55:54,180 --> 00:55:55,930
 Dan mungkin tidak, itu akan crash. 

1219
00:55:55,930 --> 00:55:56,670
 Apakah kalian berdua? 

1220
00:55:56,670 --> 00:55:58,930
 Aha, itu tidak crash, kan. 

1221
00:55:58,930 --> 00:56:01,730
 Jadi sekarang Anda benar-benar menemukan nilai dari kenari kedua itu 

1222
00:56:01,730 --> 00:56:02,530
 byte, benar. 

1223
00:56:02,530 --> 00:56:04,770
 Seperti yang Anda bayangkan, Anda melangkah dengan cara ini, 

1224
00:56:04,770 --> 00:56:07,849
 dan akhirnya Anda menemukan semua nilai untuk canary. 

1225
00:56:07,849 --> 00:56:09,890
 Jadi sekali lagi kami memanfaatkan fakta itu, 

1226
00:56:09,890 --> 00:56:12,580
 tabrakan itu adalah sinyal untuk Anda, penyerang, 

1227
00:56:12,580 --> 00:56:15,935
 bahwa Anda benar-benar telah melakukan sesuatu yang salah, benar. 

1228
00:56:15,935 --> 00:56:17,810
 Dan server sedang begadang, dengan kata lain, 

1229
00:56:17,810 --> 00:56:19,830
 koneksi soket itu tetap terbuka, adalah 

1230
00:56:19,830 --> 00:56:21,579
 sebuah sinyal untuk Anda, penyerang, yang Anda miliki 

1231
00:56:21,579 --> 00:56:22,774
 melakukan sesuatu dengan benar. 

1232
00:56:22,774 --> 00:56:24,940
 AUDIENCE: Mungkin saya menyebutkan sesuatu yang mendasar di sini 

1233
00:56:24,940 --> 00:56:27,610
 seperti mengapa kamu-- jika kamu tahu berapa lama kenari itu, 

1234
00:56:27,610 --> 00:56:28,818
 bisakah kamu langsung menginfeksi? 

1235
00:56:28,818 --> 00:56:31,632
 Lewati buffer itu dan limpahi itu-- 

1236
00:56:31,632 --> 00:56:33,508
 satu-satunya jalan di sana kenari itu? 

1237
00:56:33,508 --> 00:56:37,460
 Jadi seperti [TIDAK JELAS] katakan Anda dapat menyukai [TIDAK JELAS] kenari-- 

1238
00:56:37,460 --> 00:56:39,620
 PROFESOR: Ya, ya Anda tidak bisa - jadi itu benar 

1239
00:56:39,620 --> 00:56:41,890
 jika Anda - jadi jika Anda sebenarnya tahu lokasi yang tepat 

1240
00:56:41,890 --> 00:56:42,801
 dari kenari, benar. 

1241
00:56:42,801 --> 00:56:44,300
 Terkadang hal itu memungkinkan Anda melewati 

1242
00:56:44,300 --> 00:56:45,420
 beberapa serangan ini benar-benar. 

1243
00:56:45,420 --> 00:56:46,480
 Karena dengan begitu Anda bisa langsung saja 

1244
00:56:46,480 --> 00:56:48,340
 tulis ke alamat pengirim, katakanlah, 

1245
00:56:48,340 --> 00:56:51,180
 sebagai lawan melakukan beberapa omong kosong buffer overflow ini. 

1246
00:56:51,180 --> 00:56:53,430
 Tetapi secara umum, jika ada beberapa tingkat pengacakan 

1247
00:56:53,430 --> 00:56:56,050
 di sini, jika Anda tidak tahu di mana tumpukan itu misalnya, 

1248
00:56:56,050 --> 00:56:57,810
 maka itu sulit untuk melakukan itu, benar. 

1249
00:56:57,810 --> 00:56:59,685
 Jadi pada dasarnya cara penyerangan berlangsung 

1250
00:56:59,685 --> 00:57:01,800
 adalah Anda tidak tahu apa yang terjadi, 

1251
00:57:01,800 --> 00:57:06,710
 dan Anda hanya perlahan-lahan merayap ke memori Anda, 

1252
00:57:06,710 --> 00:57:09,184
 bawah tumpukan, untuk mencari tahu di mana hal-hal ini. 

1253
00:57:09,184 --> 00:57:11,112
 AUDIENCE: Dapatkah server, bukan 

1254
00:57:11,112 --> 00:57:13,522
 menabrak ketika menemukan kenari yang kuat, 

1255
00:57:13,522 --> 00:57:15,932
 menjaga agar soket tetap terbuka dan [tidak terdengar] akan mati 

1256
00:57:15,932 --> 00:57:18,149
 dan [TIDAK JELAS]? 

1257
00:57:18,149 --> 00:57:20,440
 PROFESOR: Ya, jadi kita akan bahas di akhir kuliah 

1258
00:57:20,440 --> 00:57:22,630
 beberapa pertahanan yang bisa Anda miliki melawan ini, 

1259
00:57:22,630 --> 00:57:25,790
 tapi satu pertahanan sipil yang sangat, secara abstrak, 

1260
00:57:25,790 --> 00:57:28,220
 adalah ketika program macet, 

1261
00:57:28,220 --> 00:57:30,222
 Anda menangkap segfault menggunakan penangan sinyal, 

1262
00:57:30,222 --> 00:57:31,930
 jangan menyimpulkan kode Anda sendiri dengan cara itu. 

1263
00:57:31,930 --> 00:57:33,055
 Tetapi Anda dapat melakukan ini, benar. 

1264
00:57:33,055 --> 00:57:35,250
 Anda menangkap segfault itu dan kemudian penangan sinyal 

1265
00:57:35,250 --> 00:57:37,247
 biarkan proses itu tetap hidup sebentar 

1266
00:57:37,247 --> 00:57:39,330
 dan itu akan mengelabui serangan itu dengan memikirkan itu, 

1267
00:57:39,330 --> 00:57:45,570
 oh saya tidak akan mendapatkan sinyal itu kembali, dengan kata lain. 

1268
00:57:45,570 --> 00:57:48,000
 OK jadi itu pada dasarnya bagaimana Anda bisa 

1269
00:57:48,000 --> 00:57:49,710
 tebak nilai untuk kenari. 

1270
00:57:49,710 --> 00:57:51,700
 Dan perhatikan bahwa Anda benar-benar dapat menggunakan serangan ini 

1271
00:57:51,700 --> 00:57:54,285
 untuk mengurutkan angka nilai acak itu 

1272
00:57:54,285 --> 00:57:56,020
 rendah dalam tumpukan, benar. 

1273
00:57:56,020 --> 00:57:58,790
 Hanya dengan menebak-nebak setiap byte apa adanya, 

1274
00:57:58,790 --> 00:58:00,490
 dan kemudian menggunakan indikasi kecelakaan itu 

1275
00:58:00,490 --> 00:58:04,960
 sebagai tanda apakah Anda menebak itu benar atau tidak. 

1276
00:58:04,960 --> 00:58:07,820
 Jadi pada dasarnya itulah cara Anda bisa mengalahkan 

1277
00:58:07,820 --> 00:58:09,460
 ini canary acak, dengan asumsi 

1278
00:58:09,460 --> 00:58:14,000
 bahwa setelah server dimulai ulang, hal-hal itu tidak berubah. 

1279
00:58:14,000 --> 00:58:15,575
 Dan kami juga menunjukkan bagaimana Anda bisa 

1280
00:58:15,575 --> 00:58:17,800
 gunakan gadget untuk menyatukan 

1281
00:58:17,800 --> 00:58:19,460
 serangan yang lebih rumit ini. 

1282
00:58:19,460 --> 00:58:21,730
 Jadi apa yang akan kita lihat selanjutnya 

1283
00:58:21,730 --> 00:58:25,770
 adalah cara yang dapat Anda gunakan untuk mengalahkan semua teknik ini 

1284
00:58:25,770 --> 00:58:29,300
 pencegahan pelaksanaan data, pengacakan berbasis alamat 

1285
00:58:29,300 --> 00:58:32,674
 dan kenari pada sistem produksi. 

1286
00:58:32,674 --> 00:58:34,090
 Sekarang apa yang akan kita lakukan sekarang adalah, 

1287
00:58:34,090 --> 00:58:35,800
 kita benar-benar akan mulai mencari 

1288
00:58:35,800 --> 00:58:38,870
 di arsitektur 64-bit, bukan arsitektur 32-bit. 

1289
00:58:38,870 --> 00:58:41,330
 Karena ternyata untuk tujuan pengacakan, 

1290
00:58:41,330 --> 00:58:43,750
 Arsitektur 64-bit benar-benar memberi Anda 

1291
00:58:43,750 --> 00:58:47,280
 lebih banyak keacakan untuk melindungi diri sendiri melawan penyerang. 

1292
00:58:47,280 --> 00:58:49,260
 Jadi melihat serangan jauh lebih menarik 

1293
00:58:49,260 --> 00:58:50,850
 pada sistem tersebut. 

1294
00:58:50,850 --> 00:58:52,800
 Jadi itu juga tipe arsitekturnya 

1295
00:58:52,800 --> 00:58:54,690
 dibahas di kertas BROP. 

1296
00:58:54,690 --> 00:58:56,245
 Mereka berbicara tentang mesin 64-bit. 

1297
00:58:56,245 --> 00:58:57,620
 Jadi mulai sekarang, anggap itu kita 

1298
00:58:57,620 --> 00:58:59,950
 akan berbicara tentang arsitektur 64-bit. 

1299
00:58:59,950 --> 00:59:01,640
 Untuk keperluan diskusi ini, 

1300
00:59:01,640 --> 00:59:03,740
 satu-satunya perbedaan antara mesin 32-bit 

1301
00:59:03,740 --> 00:59:07,360
 dan mesin 64-bit, adalah pada mesin 32-bit, 

1302
00:59:07,360 --> 00:59:10,500
 Argumennya diteruskan pada stack, benar. 

1303
00:59:10,500 --> 00:59:14,620
 Jadi di sini misalnya, ini seperti mesin 32-bit 

1304
00:59:14,620 --> 00:59:16,480
 kami mengasumsikan, jadi misalnya, bash path 

1305
00:59:16,480 --> 00:59:17,570
 akan meneruskan tumpukan. 

1306
00:59:17,570 --> 00:59:19,810
 Pada mesin 64-bit, argumennya 

1307
00:59:19,810 --> 00:59:22,350
 dilewatkan dalam register sebagai gantinya. 

1308
00:59:22,350 --> 00:59:24,570
 OK jadi seperti ketika suatu fungsi mulai eksekusi, 

1309
00:59:24,570 --> 00:59:26,195
 itu akan terlihat di register tertentu 

1310
00:59:26,195 --> 00:59:28,320
 untuk menemukan di mana argumennya. 

1311
00:59:28,320 --> 00:59:29,040
 Oke, masuk akal? 

1312
00:59:29,040 --> 00:59:30,250
 Baiklah. 

1313
00:59:30,250 --> 00:59:33,950
 Jadi, mulai di sini. 

1314
00:59:33,950 --> 00:59:41,400


1315
00:59:41,400 --> 00:59:45,210
 Baiklah, sekarang kita sampai pada makalah hari ini. 

1316
00:59:45,210 --> 00:59:48,200
 Yang merupakan pemrograman berorientasi kembali buta. 

1317
00:59:48,200 --> 00:59:51,380
 Jadi apa hal pertama yang ingin Anda lakukan, 

1318
00:59:51,380 --> 00:59:54,970
 jika Anda ingin terlibat dalam BROP untuk bersenang-senang atau untung? 

1319
00:59:54,970 --> 00:59:57,080
 Jadi, hal pertama yang harus Anda lakukan 

1320
00:59:57,080 --> 01:00:01,170
 adalah, Anda harus menemukan apa yang mereka sebut gadget berhenti. 

1321
01:00:01,170 --> 01:00:06,970


1322
01:00:06,970 --> 01:00:10,270
 Sekarang berhenti gadget-- dan ingat bahwa ketika kita mengatakan gadget, 

1323
01:00:10,270 --> 01:00:13,510
 pada dasarnya kami berarti, alamat pengirim, benar. 

1324
01:00:13,510 --> 01:00:15,630
 Gadget diidentifikasi oleh alamat pengirim, 

1325
01:00:15,630 --> 01:00:18,280
 oleh alamat awal dari urutan instruksi itu 

1326
01:00:18,280 --> 01:00:19,660
 yang ingin kita lompati, benar. 

1327
01:00:19,660 --> 01:00:21,030
 Jadi apa itu gadget stop? 

1328
01:00:21,030 --> 01:00:24,350
 Jadi gadget berhenti pada dasarnya adalah alamat pengirim 

1329
01:00:24,350 --> 01:00:27,580
 ke tempat di kode, tetapi jika Anda melompat ke sana, 

1330
01:00:27,580 --> 01:00:29,340
 Anda akan menghentikan programnya, 

1331
01:00:29,340 --> 01:00:31,890
 tetapi Anda tidak akan merusaknya. 

1332
01:00:31,890 --> 01:00:35,070
 Oke, itulah mengapa disebut gadget berhenti. 

1333
01:00:35,070 --> 01:00:37,510
 Sekarang apa yang bisa menghentikan gadget itu? 

1334
01:00:37,510 --> 01:00:40,660
 Anda mungkin melompat ke suatu tempat di kode yang kemudian memanggil 

1335
01:00:40,660 --> 01:00:43,562
 melalui panggilan sistem tidur misalnya, atau berhenti sebentar, 

1336
01:00:43,562 --> 01:00:44,520
 atau semacam itu. 

1337
01:00:44,520 --> 01:00:46,997
 Atau mungkin entah bagaimana program macet dalam lingkaran tak terbatas 

1338
01:00:46,997 --> 01:00:48,080
 jika kamu melompat ke tempat itu. 

1339
01:00:48,080 --> 01:00:50,061
 Tidak masalah mengapa berhenti terjadi, 

1340
01:00:50,061 --> 01:00:52,185
 tetapi Anda bisa membayangkan beberapa skenario yang akan 

1341
01:00:52,185 --> 01:00:53,760
 menyebabkan itu berhenti terjadi. 

1342
01:00:53,760 --> 01:00:55,330
 Jadi mengapa ini berguna? 

1343
01:00:55,330 --> 01:00:57,554
 Nah setelah penyerang berhasil 

1344
01:00:57,554 --> 01:00:59,720
 untuk mengalahkan canaries menggunakan iteratif menebak 

1345
01:00:59,720 --> 01:01:02,080
 teknik yang saya tunjukkan, dia bisa mulai 

1346
01:01:02,080 --> 01:01:05,850
 untuk menimpa alamat pengirim ini dan mulai menyelidik 

1347
01:01:05,850 --> 01:01:07,900
 untuk menghentikan gadget ini, benar. 

1348
01:01:07,900 --> 01:01:09,950
 Dan perhatikan bahwa sebagian besar acak 

1349
01:01:09,950 --> 01:01:12,110
 alamat yang mungkin Anda taruh di sana, mereka akan 

1350
01:01:12,110 --> 01:01:13,654
 mungkin menabrak server, kan. 

1351
01:01:13,654 --> 01:01:15,820
 Sekali lagi, itulah pesan untuk Anda, penyerang, 

1352
01:01:15,820 --> 01:01:18,601
 itu adalah indikasi bahwa apa yang Anda temukan bukan gadget berhenti, 

1353
01:01:18,601 --> 01:01:19,100
 kanan. 

1354
01:01:19,100 --> 01:01:21,016
 Karena ketika server crash soket Anda - 

1355
01:01:21,016 --> 01:01:22,420
 koneksi soket Anda tertutup. 

1356
01:01:22,420 --> 01:01:23,653
 Anda sebagai penyerang tahu, oke itu tidak boleh 

1357
01:01:23,653 --> 01:01:24,660
 telah menjadi gadget berhenti. 

1358
01:01:24,660 --> 01:01:27,201
 Di mana jika Anda menebak sesuatu dan kemudian Anda-- soket itu masih ada 

1359
01:01:27,201 --> 01:01:28,720
 tetap terbuka untuk sementara, Anda berpikir, 

1360
01:01:28,720 --> 01:01:31,620
 aha saya menemukan gadget berhenti itu. 

1361
01:01:31,620 --> 01:01:33,890
 Jadi itulah ide dasar di balik langkah pertama. 

1362
01:01:33,890 --> 01:01:36,220
 Anda harus menemukan gadget berhenti itu. 

1363
01:01:36,220 --> 01:01:42,590
 Sekarang langkah kedua, apakah itu yang ingin Anda temukan 

1364
01:01:42,590 --> 01:01:46,560
 gadget yang mengisi entri tumpukan. 

1365
01:01:46,560 --> 01:01:57,500


1366
01:01:57,500 --> 01:02:02,220
 Jadi pada dasarnya Anda harus menggunakan urutan ini dengan hati-hati 

1367
01:02:02,220 --> 01:02:03,910
 instruksi dibuat untuk mencari tahu 

1368
01:02:03,910 --> 01:02:08,040
 ketika kita punya salah satu dari tumpukan gadget ini. 

1369
01:02:08,040 --> 01:02:10,530
 Jadi urutan ini akan terdiri 

1370
01:02:10,530 --> 01:02:18,450
 dari alamat probe, alamat berhenti, dan alamat macet. 

1371
01:02:18,450 --> 01:02:20,489
 Jadi alamat probe adalah hal 

1372
01:02:20,489 --> 01:02:22,030
 yang akan kita masukkan ke dalam tumpukan. 

1373
01:02:22,030 --> 01:02:32,036
 Ini akan menjadi alamat dari tumpukan potensial yang muncul 

1374
01:02:32,036 --> 01:02:32,535
 gadget. 

1375
01:02:32,535 --> 01:02:36,760


1376
01:02:36,760 --> 01:02:41,410
 Gadget stop ini akan menjadi apa yang kami temukan di langkah pertama. 

1377
01:02:41,410 --> 01:02:46,876
 Jadi ini adalah alamat dari gadget berhenti. 

1378
01:02:46,876 --> 01:02:49,550


1379
01:02:49,550 --> 01:02:51,780
 Dan kemudian gadget macet hanya 

1380
01:02:51,780 --> 01:02:56,683
 akan menjadi alamat kode yang tidak dapat dieksekusi. 

1381
01:02:56,683 --> 01:03:02,295


1382
01:03:02,295 --> 01:03:03,920
 Jadi misalnya, Anda bisa mengatur ini 

1383
01:03:03,920 --> 01:03:06,957
 untuk, hanya alamat nol, benar. 

1384
01:03:06,957 --> 01:03:09,415
 Jika Anda melakukan ret ke ini dan kemudian mencoba mengeksekusi kode di sana, 

1385
01:03:09,415 --> 01:03:11,250
 ini akan merusak program Anda. 

1386
01:03:11,250 --> 01:03:14,830
 Jadi pada dasarnya kami dapat menggunakan jenis alamat ini 

1387
01:03:14,830 --> 01:03:17,360
 untuk mencari tahu di mana tumpukan popping gadget ini. 

1388
01:03:17,360 --> 01:03:20,870
 Jadi, inilah contoh sederhana. 

1389
01:03:20,870 --> 01:03:24,640
 Jadi mari tulis ini di sini. 

1390
01:03:24,640 --> 01:03:31,730
 Jadi katakanlah kita memiliki dua contoh probe yang berbeda ini, 

1391
01:03:31,730 --> 01:03:36,600
 jebakan, dan kemudian berhenti, benar. 

1392
01:03:36,600 --> 01:03:40,290
 Jadi mari kita asumsikan bahwa kita ada di sini, 

1393
01:03:40,290 --> 01:03:44,380
 kita akan menyelidiki beberapa alamat, 

1394
01:03:44,380 --> 01:03:46,130
 tidak terlalu penting, dimulai dengan empat, 

1395
01:03:46,130 --> 01:03:46,921
 diakhiri dengan delapan. 

1396
01:03:46,921 --> 01:03:47,840
 Itu tidak masalah. 

1397
01:03:47,840 --> 01:03:50,230
 Di sini, katakanlah kita melihat alamatnya 

1398
01:03:50,230 --> 01:03:54,220
 itu, katakanlah dimulai dalam empat ujung dalam C. 

1399
01:03:54,220 --> 01:03:56,520
 Jadi kami katakan, kami berhipotesis, 

1400
01:03:56,520 --> 01:03:59,270
 yang mungkin salah satu dari dua alamat ini 

1401
01:03:59,270 --> 01:04:02,190
 akan menjadi salah satu dari gadget stack popping ini. 

1402
01:04:02,190 --> 01:04:05,100
 Dan kemudian katakan bahwa jebakan di sini, 

1403
01:04:05,100 --> 01:04:10,790
 seperti saya katakan ini hanya akan alamat nol, 

1404
01:04:10,790 --> 01:04:14,540
 dan kemudian mari kita asumsikan bahwa kita menemukan beberapa pemberhentian yang sudah ada sebelumnya 

1405
01:04:14,540 --> 01:04:19,380
 gadget, beberapa alamat memulai [tidak terdengar] tidak benar-benar 

1406
01:04:19,380 --> 01:04:19,910
 masalah. 

1407
01:04:19,910 --> 01:04:24,720
 Dan ingat ini menghentikan gadget, seperti mungkin alamat ini, 

1408
01:04:24,720 --> 01:04:29,650
 menunjukkan kode yang melakukan sesuatu seperti tidur 10, 

1409
01:04:29,650 --> 01:04:31,370
 atau sesuatu seperti itu, benar. 

1410
01:04:31,370 --> 01:04:33,720
 Jadi ketika saya mengatakan bahwa kita akan menguji urutan ini, 

1411
01:04:33,720 --> 01:04:35,920
 ini adalah hal-hal yang akan kita dorong ke dalam tumpukan, 

1412
01:04:35,920 --> 01:04:36,460
 kanan. 

1413
01:04:36,460 --> 01:04:40,386
 Begitu mirip di sana, ketika kami mendorong gadget ini 

1414
01:04:40,386 --> 01:04:41,760
 ke tumpukan, ini barangnya 

1415
01:04:41,760 --> 01:04:42,885
 bahwa kita akan mendorong ke tumpukan, 

1416
01:04:42,885 --> 01:04:45,150
 dan kita akan melihat apa yang terjadi, benar. 

1417
01:04:45,150 --> 01:04:51,800
 Sekarang katakanlah, kode ini di sini, menunjuk 

1418
01:04:51,800 --> 01:04:53,750
 ke urutan berikut. 

1419
01:04:53,750 --> 01:04:58,880
 Kita akan membuka daftar, katakanlah rak, 

1420
01:04:58,880 --> 01:05:03,340
 lalu kita akan kembali. 

1421
01:05:03,340 --> 01:05:05,210
 Jadi apa yang akan terjadi di sini? 

1422
01:05:05,210 --> 01:05:10,560
 Nah jadi ketika sistem melompat alamat ini, 

1423
01:05:10,560 --> 01:05:13,440
 stack pointer akan pindah ke sini, OK. 

1424
01:05:13,440 --> 01:05:15,380
 Sekarang kita berada di tengah-tengah gadget ini, benar. 

1425
01:05:15,380 --> 01:05:16,630
 Apa yang akan dilakukan gadget? 

1426
01:05:16,630 --> 01:05:18,450
 Ini akan menjadi rak pop, oke. 

1427
01:05:18,450 --> 01:05:20,582
 Bagian atas tumpukan pointer sekarang di sini, dan itu 

1428
01:05:20,582 --> 01:05:22,915
 akan kembali ke apa pun yang ada di bagian atas tumpukan itu 

1429
01:05:22,915 --> 01:05:24,880
 adalah jeda berhenti, benar. 

1430
01:05:24,880 --> 01:05:29,240
 Jadi dalam hal ini gadget ini membawa kita ke sini, 

1431
01:05:29,240 --> 01:05:31,358
 dan penyerang dapat mengatakan ini 

1432
01:05:31,358 --> 01:05:34,720
 is-- alamat probe ini milik salah satu tumpukan pop ini 

1433
01:05:34,720 --> 01:05:35,820
 hal-hal, benar. 

1434
01:05:35,820 --> 01:05:38,400
 Karena koneksi klien tetap terbuka. 

1435
01:05:38,400 --> 01:05:41,400
 Sekarang katakanlah gadget ini di sini, 

1436
01:05:41,400 --> 01:05:48,580
 menunjuk sesuatu seperti berikut ini. 

1437
01:05:48,580 --> 01:05:52,760
 Mungkin itu hanya seperti xor, misalnya. 

1438
01:05:52,760 --> 01:05:58,000
 Jadi itu hanya akan mengubah beberapa register dan kemudian itu 

1439
01:05:58,000 --> 01:06:00,540
 akan ret. 

1440
01:06:00,540 --> 01:06:02,930
 Jadi apa yang terjadi jika kita mencoba melompat ke gadget ini? 

1441
01:06:02,930 --> 01:06:06,170
 Benar, perhatikan bahwa ini tidak mengeluarkan apa pun dari tumpukan, OK. 

1442
01:06:06,170 --> 01:06:07,920
 Itu hanya mengubah isi register. 

1443
01:06:07,920 --> 01:06:09,160
 Jadi apa yang akan terjadi? 

1444
01:06:09,160 --> 01:06:11,690
 Jadi kita akan berada di sini, kita akan pergi 

1445
01:06:11,690 --> 01:06:13,630
 untuk melompat ke alamat gadget ini, 

1446
01:06:13,630 --> 01:06:15,830
 stack pointer masuk di sini, oke. 

1447
01:06:15,830 --> 01:06:18,210
 Kita akan memperhatikan kedua hal ini, benar. 

1448
01:06:18,210 --> 01:06:19,932
 Stack pointer tidak akan berubah. 

1449
01:06:19,932 --> 01:06:22,390
 Lalu kita akan kembali ke bagian atas tumpukan apa pun 

1450
01:06:22,390 --> 01:06:23,550
 adalah, yaitu 0, 0. 

1451
01:06:23,550 --> 01:06:25,370
 Ini akan crash. 

1452
01:06:25,370 --> 01:06:28,420
 OK, koneksi klien ke server akan ditutup, 

1453
01:06:28,420 --> 01:06:31,245
 dan sebagai hasilnya, penyerang tahu bahwa ini bukan 

1454
01:06:31,245 --> 01:06:34,210
 gadget stack popping. 

1455
01:06:34,210 --> 01:06:35,990
 Jadi apakah itu semua masuk akal? 

1456
01:06:35,990 --> 01:06:38,850
 Dan Anda juga dapat membayangkan bahwa Anda dapat-- 

1457
01:06:38,850 --> 01:06:42,609
 dengan datang dengan lebih banyak seri barok 

1458
01:06:42,609 --> 01:06:44,150
 dan menghentikan gadget dan hal-hal seperti itu, 

1459
01:06:44,150 --> 01:06:46,510
 Anda dapat menemukan hal-hal yang misalnya, pop dua hal 

1460
01:06:46,510 --> 01:06:47,879
 dari tumpukan, benar. 

1461
01:06:47,879 --> 01:06:50,170
 Anda bisa memasukkan satu lagi dari petunjuk perangkap ini 

1462
01:06:50,170 --> 01:06:51,110
 di sana, benar. 

1463
01:06:51,110 --> 01:06:53,166
 Dan kemudian kecuali ... kecuali gadget ini 

1464
01:06:53,166 --> 01:06:54,540
 muncul dua hal, Anda akan pergi 

1465
01:06:54,540 --> 01:06:56,831
 berakhir di salah satu perangkap ini dan eksekusi kode Anda 

1466
01:06:56,831 --> 01:06:58,250
 akan meledak, benar. 

1467
01:06:58,250 --> 01:07:02,090
 Maka di koran mereka berdiskusi seperti ini yang disebut BROP 

1468
01:07:02,090 --> 01:07:03,950
 gadget, yang semacam suka meriah 

1469
01:07:03,950 --> 01:07:06,300
 rumit jika Anda tidak terbiasa kembali ke pemrograman. 

1470
01:07:06,300 --> 01:07:08,297
 Apa yang akan saya tunjukkan hari ini adalah Anda benar-benar bisa 

1471
01:07:08,297 --> 01:07:09,880
 cukup gunakan gadget pop yang sangat sederhana ini 

1472
01:07:09,880 --> 01:07:10,963
 untuk meluncurkan serangan yang sama. 

1473
01:07:10,963 --> 01:07:12,690
 Maka semoga setelah Anda memahami ini, 

1474
01:07:12,690 --> 01:07:14,696
 Gadget BROP akan lebih masuk akal. 

1475
01:07:14,696 --> 01:07:16,570
 Tapi apakah semua orang mengerti bagaimana kita bisa menyelidiki 

1476
01:07:16,570 --> 01:07:19,180
 untuk gadget kecil ini di sini? 

1477
01:07:19,180 --> 01:07:20,120
 BAIK. 

1478
01:07:20,120 --> 01:07:26,220
 Jadi, begitu Anda punya gadget ini, apa yang Anda ketahui? 

1479
01:07:26,220 --> 01:07:28,720
 Nah Anda menemukan lokasi cuplikan kode itu 

1480
01:07:28,720 --> 01:07:31,080
 memungkinkan Anda untuk pop up, satu hal dari tumpukan. 

1481
01:07:31,080 --> 01:07:32,820
 Tepat satu hal dari tumpukan itu, 

1482
01:07:32,820 --> 01:07:35,990
 tetapi Anda tidak benar-benar tahu apa yang mendaftar 

1483
01:07:35,990 --> 01:07:37,990
 mereka bermunculan. 

1484
01:07:37,990 --> 01:07:40,440
 Anda hanya tahu bahwa mereka sedang dimatikan, benar. 

1485
01:07:40,440 --> 01:07:42,394
 Dan Anda sebenarnya perlu tahu apa 

1486
01:07:42,394 --> 01:07:44,060
 daftar gadget ini bermunculan barang 

1487
01:07:44,060 --> 01:07:47,370
 dalam, karena ingat, pada arsitektur 64-bit, 

1488
01:07:47,370 --> 01:07:50,840
 register mengontrol tempat argumen untuk fungsi ini 

1489
01:07:50,840 --> 01:07:52,480
 yang ingin Anda panggil, benar. 

1490
01:07:52,480 --> 01:07:54,170
 Jadi tujuan utama yang perlu diingat, 

1491
01:07:54,170 --> 01:07:56,419
 adalah bahwa kita ingin dapat membuat beberapa gadget itu 

1492
01:07:56,419 --> 01:07:58,920
 izinkan kami untuk memunculkan nilai yang kami taruh di tumpukan 

1493
01:07:58,920 --> 01:08:00,754
 ke dalam register tertentu, dan akhirnya kita 

1494
01:08:00,754 --> 01:08:02,794
 akan memanggil panggilan sistem yang akan memungkinkan 

1495
01:08:02,794 --> 01:08:03,850
 kita melakukan sesuatu yang jahat. 

1496
01:08:03,850 --> 01:08:05,870
 Oke, jadi hal berikutnya yang perlu kita lakukan 

1497
01:08:05,870 --> 01:08:14,670
 adalah menentukan register mana - jadi tentukan yang mana 

1498
01:08:14,670 --> 01:08:19,024
 mendaftarkan penggunaan gadget pop. 

1499
01:08:19,024 --> 01:08:26,318


1500
01:08:26,319 --> 01:08:28,870
 Jadi bagaimana kita akan melakukan itu? 

1501
01:08:28,870 --> 01:08:32,160
 Nah pada dasarnya kita dapat memanfaatkan sistem pause 

1502
01:08:32,160 --> 01:08:32,840
 panggilan. 

1503
01:08:32,840 --> 01:08:37,580
 OK, jadi panggilan sistem jeda, tidak perlu argumen, benar. 

1504
01:08:37,580 --> 01:08:40,970
 Dan itu berarti bahwa itu mengabaikan segala sesuatu di dalam register. 

1505
01:08:40,970 --> 01:08:41,930
 BAIK. 

1506
01:08:41,930 --> 01:08:45,129
 Dan intinya, untuk menemukan instruksi jeda apa 

1507
01:08:45,129 --> 01:08:49,760
 yang bisa kita lakukan adalah, kita dapat mengatur semua gadget pop ini 

1508
01:08:49,760 --> 01:08:52,490
 sedemikian rupa, bahwa kita menempatkan mereka semua di atas tumpukan, 

1509
01:08:52,490 --> 01:08:55,229
 di antara masing-masing dari mereka kita memasukkan nomor syscall 

1510
01:08:55,229 --> 01:08:57,738
 untuk jeda, dan kemudian kita melihat apakah kita bisa benar-benar 

1511
01:08:57,738 --> 01:08:59,268
 dapatkan program untuk digantung. 

1512
01:08:59,269 --> 01:09:01,060
 Biarkan saya memberi Anda contoh nyata tentang itu. 

1513
01:09:01,060 --> 01:09:05,050
 Jadi kami akan melakukan sesuatu seperti ini. 

1514
01:09:05,050 --> 01:09:09,390


1515
01:09:09,390 --> 01:09:13,850
 Jadi di sini untuk alamat pengirim, kami akan memasukkan yang berikut. 

1516
01:09:13,850 --> 01:09:24,290


1517
01:09:24,290 --> 01:09:28,750
 Jadi katakanlah kita memiliki satu gadget yang muncul register RDI, 

1518
01:09:28,750 --> 01:09:30,899
 kemudian melakukan ret. 

1519
01:09:30,899 --> 01:09:40,090
 Dan kemudian di sini kita akan memasukkan nomor syscall untuk jeda. 

1520
01:09:40,090 --> 01:09:45,810
 Dan kemudian katakanlah bahwa kita memiliki gadget lain yang kami temukan, 

1521
01:09:45,810 --> 01:09:50,600
 yang melakukan pop ke daftar yang berbeda, katakanlah RSI. 

1522
01:09:50,600 --> 01:09:53,960


1523
01:09:53,960 --> 01:09:58,670
 Dan kemudian kami akan memasukkan nomor panggilan sistem untuk jeda 

1524
01:09:58,670 --> 01:09:59,460
 di sini lagi. 

1525
01:09:59,460 --> 01:10:02,124


1526
01:10:02,124 --> 01:10:05,640
 Dan kami melakukan ini untuk semua gadget yang kami temukan 

1527
01:10:05,640 --> 01:10:15,947
 dan akhirnya kami menaruh alamat tamu untuk jeda, 

1528
01:10:15,947 --> 01:10:17,280
 atau maaf untuk syscall, permisi. 

1529
01:10:17,280 --> 01:10:25,370


1530
01:10:25,370 --> 01:10:28,510
 Sekali lagi, ingat bagaimana Anda memanggil panggilan sistem ini. 

1531
01:10:28,510 --> 01:10:32,990
 Jadi pada dasarnya Anda harus meletakkan nomor dari panggilan sistem 

1532
01:10:32,990 --> 01:10:36,560
 ke dalam register RAX, maka Anda menjalankan fungsi libc ini 

1533
01:10:36,560 --> 01:10:39,855
 syscall yang kemudian akan menjalankan sistem yang diminta 

1534
01:10:39,855 --> 01:10:40,784
 panggilan, oke. 

1535
01:10:40,784 --> 01:10:42,950
 Jadi apa yang akan terjadi ketika kita menjalankan kode ini? 

1536
01:10:42,950 --> 01:10:46,120
 Benar, jadi kita akan datang ke sini, 

1537
01:10:46,120 --> 01:10:48,580
 kita akan lompat ke alamat gadget ini, 

1538
01:10:48,580 --> 01:10:50,840
 dan perhatikan itu sebagai penyerang, semua yang kita tahu 

1539
01:10:50,840 --> 01:10:53,610
 adalah bahwa gadget ini di sini muncul sesuatu dari tumpukan. 

1540
01:10:53,610 --> 01:10:55,680
 Kami belum tahu apa registernya, benar. 

1541
01:10:55,680 --> 01:10:57,080
 Taruh di sini hanya untuk membuat [TIDAK JELAS], 

1542
01:10:57,080 --> 01:10:58,788
 tapi penyerang belum tahu, benar. 

1543
01:10:58,788 --> 01:11:01,560
 Jadi jika Anda melompat-- atau minta maaf-- kita melompat 

1544
01:11:01,560 --> 01:11:03,664
 ke gadget, sudut tumpukan sekarang di sini, 

1545
01:11:03,664 --> 01:11:04,580
 apa yang akan dilakukannya? 

1546
01:11:04,580 --> 01:11:07,720
 Ini akan mem-pop nomor syscall ini untuk jeda, 

1547
01:11:07,720 --> 01:11:09,870
 dalam beberapa register penyerang tidak tahu, 

1548
01:11:09,870 --> 01:11:14,006
 dan kemudian kita akan terus naik rantai ini dan sebagainya 

1549
01:11:14,006 --> 01:11:14,700
 dan seterusnya. 

1550
01:11:14,700 --> 01:11:17,470
 Dan yang akan Anda lihat adalah masing-masing gadget ini, satu 

1551
01:11:17,470 --> 01:11:20,430
 dari mereka semoga akan muncul panggilan sistem 

1552
01:11:20,430 --> 01:11:23,500
 nomor ke register RAX yang sesuai. 

1553
01:11:23,500 --> 01:11:25,980
 Sehingga pada saat kita bangun di sini, 

1554
01:11:25,980 --> 01:11:28,320
 Maksudku kita pada dasarnya mencemari semua register, 

1555
01:11:28,320 --> 01:11:31,090
 dengan nomor panggilan sistem, tapi mudah-mudahan hanya salah satu dari mereka 

1556
01:11:31,090 --> 01:11:32,460
 harus benar, benar. 

1557
01:11:32,460 --> 01:11:35,510
 Karena jika salah satu gadget kami melakukan ini, maka pada saat itu 

1558
01:11:35,510 --> 01:11:37,610
 kita kembali ke sini, kita akan mendapat jeda. 

1559
01:11:37,610 --> 01:11:42,310
 Sekali lagi, jeda itu bertindak sebagai sinyal bagi penyerang, OK. 

1560
01:11:42,310 --> 01:11:44,980
 Karena jika alamat tamu ini salah, 

1561
01:11:44,980 --> 01:11:47,710
 maka mungkin programnya akan crash, benar. 

1562
01:11:47,710 --> 01:11:51,540
 Jadi apa fase serangan ini yang harus kita lakukan? 

1563
01:11:51,540 --> 01:11:54,300
 Kami masih belum tahu gadget mana 

1564
01:11:54,300 --> 01:11:56,860
 pop ke dalam register, tetapi kita tahu bahwa salah satu dari mereka 

1565
01:11:56,860 --> 01:11:59,600
 muncul dalam RAX, yang mana yang ingin kita kendalikan. 

1566
01:11:59,600 --> 01:12:03,690
 Dan pastinya kita tahu alamat syscall, benar. 

1567
01:12:03,690 --> 01:12:06,790
 Karena kami mampu menginduksi jeda, benar. 

1568
01:12:06,790 --> 01:12:09,330
 Jadi, setelah kami selesai melakukannya, benar. 

1569
01:12:09,330 --> 01:12:12,000
 Setelah kami tahu pasti di mana benda ini, 

1570
01:12:12,000 --> 01:12:14,200
 alamat untuk syscall, maka kita sebenarnya bisa 

1571
01:12:14,200 --> 01:12:16,299
 coba gadget satu per satu, benar. 

1572
01:12:16,299 --> 01:12:18,090
 Dan lihat mana yang benar-benar terjadi 

1573
01:12:18,090 --> 01:12:19,474
 untuk menginduksi jeda, benar. 

1574
01:12:19,474 --> 01:12:21,640
 Jadi dengan kata lain, potong semua perantara di sini, mari 

1575
01:12:21,640 --> 01:12:24,760
 memiliki tumpukan seperti ini, dan kemudian Anda segera 

1576
01:12:24,760 --> 01:12:25,590
 melompat ke syscall. 

1577
01:12:25,590 --> 01:12:27,790
 Apakah itu menyebabkan jeda atau apakah itu crash? 

1578
01:12:27,790 --> 01:12:29,680
 Jika macet, OK kita tahu gadget ini, 

1579
01:12:29,680 --> 01:12:31,200
 itu muncul untuk RDI misalnya. 

1580
01:12:31,200 --> 01:12:32,700
 Oke, singkirkan yang itu, benar. 

1581
01:12:32,700 --> 01:12:34,769
 Coba gadget berikutnya, benar. 

1582
01:12:34,769 --> 01:12:37,310
 Masukkan alamat tamu - tempatkan, baik itu bukan tamu lagi, 

1583
01:12:37,310 --> 01:12:39,270
 masukkan alamat asli untuk syscall di sini. 

1584
01:12:39,270 --> 01:12:41,011
 Apakah kami dapat menghentikan program ini? 

1585
01:12:41,011 --> 01:12:41,510
 Iya nih? 

1586
01:12:41,510 --> 01:12:47,420
 Aha, jadi kami tahu bahwa gadget pop harus muncul di RAX. 

1587
01:12:47,420 --> 01:12:49,836
 Jadi apakah itu masuk akal? 

1588
01:12:49,836 --> 01:12:53,280
 AUDIENCE: Jadi cara menebak alamat untuk panggilan sistem 

1589
01:12:53,280 --> 01:12:54,756
 hanya transfer buta? 

1590
01:12:54,756 --> 01:12:57,020
 PROFESOR: Ya, jadi ada - jadi di koran, 

1591
01:12:57,020 --> 01:12:58,929
 mereka masuk ke beberapa pengoptimalan tentang caranya 

1592
01:12:58,929 --> 01:13:00,970
 Anda dapat bekerja dalam PLT dan semua hal semacam itu. 

1593
01:13:00,970 --> 01:13:03,530
 Seperti yang saya katakan, saya pikir lebih mudah untuk mengabaikan itu untuk kedua, 

1594
01:13:03,530 --> 01:13:04,690
 dan hanya melihat ke hal yang lebih sederhana 

1595
01:13:04,690 --> 01:13:07,200
 pertama, tapi ya dalam serangan sederhana yang saya gambarkan, 

1596
01:13:07,200 --> 01:13:08,790
 ya Anda hanya menaruh beberapa alamat di sini 

1597
01:13:08,790 --> 01:13:11,272
 dan Anda hanya melihat jika Anda berhenti sebentar. 

1598
01:13:11,272 --> 01:13:14,070


1599
01:13:14,070 --> 01:13:17,800
 Jadi apakah itu semua masuk akal? 

1600
01:13:17,800 --> 01:13:22,370
 OK jadi pada akhirnya kita benar-benar tahu 

1601
01:13:22,370 --> 01:13:23,810
 lokasi syscall. 

1602
01:13:23,810 --> 01:13:27,460
 Kami tahu lokasi instruksi 

1603
01:13:27,460 --> 01:13:29,730
 yang melakukan pop ke RAX. 

1604
01:13:29,730 --> 01:13:32,230
 Sekarang Anda bisa membayangkan bahwa kita juga membutuhkan gadget yang pop 

1605
01:13:32,230 --> 01:13:34,300
 ke beberapa register lain juga. 

1606
01:13:34,300 --> 01:13:36,830
 Cukuplah untuk mengatakan, Anda dapat melakukan tes serupa, benar. 

1607
01:13:36,830 --> 01:13:39,780
 Jadi, bukannya suka mendorong nomor panggilan sistem untuk jeda, 

1608
01:13:39,780 --> 01:13:41,280
 dorong untuk beberapa perintah lain itu 

1609
01:13:41,280 --> 01:13:46,890
 sekarang mengambil semua argumen di RAX dan RDI misalnya, benar. 

1610
01:13:46,890 --> 01:13:48,280
 Lakukan tes yang sama, benar. 

1611
01:13:48,280 --> 01:13:49,950
 Jadi pada dasarnya Anda dapat memanfaatkan fakta 

1612
01:13:49,950 --> 01:13:52,080
 bahwa untuk set register tertentu 

1613
01:13:52,080 --> 01:13:54,750
 yang ingin Anda kendalikan, 

1614
01:13:54,750 --> 01:13:56,690
 ada beberapa panggilan sistem yang akan memberi Anda 

1615
01:13:56,690 --> 01:13:59,070
 sinyal sebagai penyerang, yang memungkinkan Anda untuk mencari tahu 

1616
01:13:59,070 --> 01:14:00,942
 apakah Anda berhasil mematahkannya atau tidak. 

1617
01:14:00,942 --> 01:14:02,400
 Benar, jadi pada akhir fase ini, 

1618
01:14:02,400 --> 01:14:05,580
 Anda pada dasarnya memiliki alamat syscall 

1619
01:14:05,580 --> 01:14:07,770
 dan alamat sekelompok gadget 

1620
01:14:07,770 --> 01:14:11,130
 yang memungkinkan Anda untuk masuk ke register sewenang-wenang. 

1621
01:14:11,130 --> 01:14:16,900
 Oke dan sekarang mari kita lihat, langkah 4 

1622
01:14:16,900 --> 01:14:19,895
 akan memohon menulis. 

1623
01:14:19,895 --> 01:14:28,970


1624
01:14:28,970 --> 01:14:35,924
 Langkah 4 adalah memanggil sistem panggilan. 

1625
01:14:35,924 --> 01:14:38,710


1626
01:14:38,710 --> 01:14:44,200
 Jadi untuk memohon menulis, kita perlu memiliki gadget berikut. 

1627
01:14:44,200 --> 01:14:48,770
 Anda harus dapat mem-pop RDI. 

1628
01:14:48,770 --> 01:14:51,400
 Kita harus bisa membuka RSI. 

1629
01:14:51,400 --> 01:14:54,310


1630
01:14:54,310 --> 01:15:06,490
 Kita harus bisa membuka RDX, rak pop, dan kemudian memanggil 

1631
01:15:06,490 --> 01:15:09,140
 syscall, benar. 

1632
01:15:09,140 --> 01:15:11,000
 Jadi ternyata, apa register ini 

1633
01:15:11,000 --> 01:15:12,950
 digunakan untuk panggilan sistem? 

1634
01:15:12,950 --> 01:15:17,900
 Jadi ini adalah soket, atau lebih umum, deskriptor file 

1635
01:15:17,900 --> 01:15:20,650
 bahwa Anda akan lulus menulis. 

1636
01:15:20,650 --> 01:15:23,190
 Ini buffernya. 

1637
01:15:23,190 --> 01:15:25,080
 Ini adalah panjang buffer itu. 

1638
01:15:25,080 --> 01:15:27,680


1639
01:15:27,680 --> 01:15:30,150
 Ini adalah nomor syscall. 

1640
01:15:30,150 --> 01:15:33,970


1641
01:15:33,970 --> 01:15:35,910
 Dan itu disebut syscall. 

1642
01:15:35,910 --> 01:15:39,150
 Benar, jadi jika kami menemukan semua gadget ini, 

1643
01:15:39,150 --> 01:15:42,480
 maka kita sekarang dapat mengontrol nilai-nilai 

1644
01:15:42,480 --> 01:15:44,310
 yang dimasukkan ke dalam argumen itu, itu 

1645
01:15:44,310 --> 01:15:46,435
 dimasukkan ke dalam register itu, karena kami hanya mendorongnya 

1646
01:15:46,435 --> 01:15:47,440
 di atas tumpukan, benar. 

1647
01:15:47,440 --> 01:15:49,670
 Jadi misalnya, apa yang akan menjadi soket? 

1648
01:15:49,670 --> 01:15:51,560
 Untuk sekali ini Anda harus sedikit menebak di sini, 

1649
01:15:51,560 --> 01:15:52,060
 kanan. 

1650
01:15:52,060 --> 01:15:54,280
 dapat mengambil keuntungan dari fakta bahwa Linux membatasi 

1651
01:15:54,280 --> 01:15:56,960
 jumlah koneksi file terbuka secara bersamaan, 

1652
01:15:56,960 --> 01:15:59,050
 untuk file yang akan menjadi 2024. 

1653
01:15:59,050 --> 01:16:01,650
 Dan juga seharusnya yang terendah yang tersedia. 

1654
01:16:01,650 --> 01:16:03,858
 Jadi kami melakukan sedikit tebakan di sini dan mencari tahu 

1655
01:16:03,858 --> 01:16:05,690
 apa itu soket, taruh di sana. 

1656
01:16:05,690 --> 01:16:07,190
 Sekarang yang menarik, apa yang akan kita lakukan 

1657
01:16:07,190 --> 01:16:08,920
 untuk melewati pointer buff? 

1658
01:16:08,920 --> 01:16:10,870
 Benar, kita benar-benar akan menggunakan teks 

1659
01:16:10,870 --> 01:16:12,720
 segmen program. 

1660
01:16:12,720 --> 01:16:15,800
 Kami benar-benar akan mengirimkan pointer ke suatu tempat 

1661
01:16:15,800 --> 01:16:17,540
 dalam kode program. 

1662
01:16:17,540 --> 01:16:19,410
 Jadi apa yang akan memungkinkan kita lakukan? 

1663
01:16:19,410 --> 01:16:23,170
 Itu akan memungkinkan kita untuk membaca biner, kehabisan memori, 

1664
01:16:23,170 --> 01:16:26,750
 menggunakan panggilan yang benar ke soket klien. 

1665
01:16:26,750 --> 01:16:29,740
 Sehingga penyerang dapat mengambil biner itu, 

1666
01:16:29,740 --> 01:16:31,820
 menganalisisnya secara offline, benar. 

1667
01:16:31,820 --> 01:16:33,670
 Cukup gunakan GDB, atau apa pun, untuk mencari tahu 

1668
01:16:33,670 --> 01:16:35,080
 dimana semuanya berada. 

1669
01:16:35,080 --> 01:16:38,280
 Penyerang tahu itu sekarang, setiap kali server crash, 

1670
01:16:38,280 --> 01:16:41,300
 itu akan memiliki kumpulan hal-hal acak yang sama di dalamnya. 

1671
01:16:41,300 --> 01:16:43,950
 Jadi sekarang, setelah penyerang dapat mengetahui alamat dan offset 

1672
01:16:43,950 --> 01:16:46,350
 untuk hal-hal, sekarang penyerang bisa langsung 

1673
01:16:46,350 --> 01:16:47,850
 serang mereka, benar. 

1674
01:16:47,850 --> 01:16:49,720
 Langsung menyerang kerentanan lain, 

1675
01:16:49,720 --> 01:16:52,330
 mencari tahu cara membuka shell, seterusnya dan seterusnya. 

1676
01:16:52,330 --> 01:16:53,850
 Jadi dengan kata lain, pada intinya Anda 

1677
01:16:53,850 --> 01:16:57,880
 exfiltrated biner ke penyerang, Anda pada dasarnya hilang. 

1678
01:16:57,880 --> 01:17:02,454
 Benar, jadi ini pada dasarnya bagaimana serangan BROP bekerja. 

1679
01:17:02,454 --> 01:17:03,870
 Seperti saya katakan, di koran, ada 

1680
01:17:03,870 --> 01:17:05,882
 sekelompok optimasi, tapi sungguh Anda 

1681
01:17:05,882 --> 01:17:07,840
 perlu memahami hal ini, hal-hal mendasar, 

1682
01:17:07,840 --> 01:17:10,020
 sebelum itu optimasi akan mulai masuk akal. 

1683
01:17:10,020 --> 01:17:11,670
 Jadi kita bisa berbicara tentang pengoptimalan dengan saya secara offline 

1684
01:17:11,670 --> 01:17:13,205
 jika Anda mau, atau setelah kelas. 

1685
01:17:13,205 --> 01:17:14,580
 Tetapi untuk mencukupi untuk mengatakan, ini 

1686
01:17:14,580 --> 01:17:17,270
 dasar-dasar cara Anda meluncurkan serangan BROP. 

1687
01:17:17,270 --> 01:17:20,490
 Anda harus menemukan gadget berhenti, 

1688
01:17:20,490 --> 01:17:23,230
 temukan gadget yang berisi entri tumpukan. 

1689
01:17:23,230 --> 01:17:25,260
 Cari tahu mana dari daftar tersebut 

1690
01:17:25,260 --> 01:17:27,440
 gadget itu muncul, dan cari tahu 

1691
01:17:27,440 --> 01:17:30,330
 bagaimana mencari tahu di mana syscall berada, dan kemudian memanggil 

1692
01:17:30,330 --> 01:17:33,560
 tulis dengan mengumpulkan semua pengetahuan itu. 

1693
01:17:33,560 --> 01:17:35,729
 Jadi dengan sangat cepat, bagaimana Anda mempertahankan diri dari BROP? 

1694
01:17:35,729 --> 01:17:37,270
 Nah hal yang paling jelas adalah Anda sudah 

1695
01:17:37,270 --> 01:17:39,270
 harus reracak, benar. 

1696
01:17:39,270 --> 01:17:41,810
 Jadi fakta bahwa server tidak macet 

1697
01:17:41,810 --> 01:17:44,490
 respawn, rerandomize versinya sendiri, 

1698
01:17:44,490 --> 01:17:48,000
 yang memungkinkan tabrakan bertindak sebagai sinyal yang memungkinkan 

1699
01:17:48,000 --> 01:17:49,990
 penyerang menguji berbagai hipotesis 

1700
01:17:49,990 --> 01:17:52,010
 tentang bagaimana program bekerja. 

1701
01:17:52,010 --> 01:17:54,990
 Jadi satu pertahanan sederhana adalah memastikan 

1702
01:17:54,990 --> 01:17:58,850
 yang Anda lakukan exec ketika Anda menelurkan proses Anda, bukannya garpu, 

1703
01:17:58,850 --> 01:17:59,350
 kanan. 

1704
01:17:59,350 --> 01:18:01,990
 Karena ketika Anda menjalankan proses, Anda membuat yang benar-benar baru 

1705
01:18:01,990 --> 01:18:04,676
 ruang tata ruang acak, setidaknya di Linux, benar. 

1706
01:18:04,676 --> 01:18:07,050
 Jadi di Linux, ketika Anda mengkompilasi dengan PIE ini, Posisi 

1707
01:18:07,050 --> 01:18:09,970
 Bendera Dapat Dieksekusi Independen, Anda saja 

1708
01:18:09,970 --> 01:18:12,420
 dapatkan ruang alamat acak itu 

1709
01:18:12,420 --> 01:18:14,950
 itu baru jika Anda menggunakan exec. 

1710
01:18:14,950 --> 01:18:17,730
 Jadi acara lain yang dapat Anda gunakan hanyalah menggunakan Windows, 

1711
01:18:17,730 --> 01:18:20,350
 karena pada dasarnya Windows tidak 

1712
01:18:20,350 --> 01:18:22,240
 memiliki persamaan garpu, benar. 

1713
01:18:22,240 --> 01:18:23,890
 Jadi hore untuk kita. 

1714
01:18:23,890 --> 01:18:26,560
 Itu artinya itu di Windows, kapan saja 

1715
01:18:26,560 --> 01:18:28,400
 Anda menelurkan server baru itu, selalu 

1716
01:18:28,400 --> 01:18:31,950
 akan memiliki ruang alamat acak baru. 

1717
01:18:31,950 --> 01:18:34,440
 Saya pikir seseorang di sini menyebutkan sesuatu seperti, 

1718
01:18:34,440 --> 01:18:36,020
 apa yang akan terjadi jika misalnya, 

1719
01:18:36,020 --> 01:18:38,340
 ketika server macet, sebenarnya tidak 

1720
01:18:38,340 --> 01:18:40,230
 tutup koneksi? 

1721
01:18:40,230 --> 01:18:41,770
 Benar, jadi kamu bisa membayangkan satu hal 

1722
01:18:41,770 --> 01:18:45,360
 bahwa ketika kecelakaan terjadi, kita entah bagaimana menangkap kesalahan itu 

1723
01:18:45,360 --> 01:18:48,050
 dan kemudian kami membiarkan koneksi itu terbuka untuk sementara waktu 

1724
01:18:48,050 --> 01:18:51,310
 untuk membingungkan penyerang dan menghapus sinyal itu, 

1725
01:18:51,310 --> 01:18:52,540
 ada sesuatu yang salah. 

1726
01:18:52,540 --> 01:18:54,690
 Jadi itu adalah sesuatu yang pasti Anda lakukan. 

1727
01:18:54,690 --> 01:18:57,720
 Apa yang lucu tentang itu, yang sekarang BROP Anda serang 

1728
01:18:57,720 --> 01:19:00,980
 berubah menjadi serangan penolakan layanan. 

1729
01:19:00,980 --> 01:19:03,280
 Karena sekarang Anda baru saja mendapatkan semua zombie potensial 

1730
01:19:03,280 --> 01:19:05,660
 proses yang duduk di sekitar, mereka segfault. 

1731
01:19:05,660 --> 01:19:07,380
 Mereka tidak berguna di masyarakat, tapi kamu 

1732
01:19:07,380 --> 01:19:09,421
 tidak bisa membiarkan mereka pergi, karena jika tidak, Anda akan pergi 

1733
01:19:09,421 --> 01:19:10,905
 untuk menghapus informasi ini. 

1734
01:19:10,905 --> 01:19:12,530
 Hal lain yang mungkin Anda pikirkan, 

1735
01:19:12,530 --> 01:19:14,155
 apakah Anda bisa melakukan pemeriksaan batas, benar. 

1736
01:19:14,155 --> 01:19:16,040
 Kami hanya berbicara banyak tentang itu, kan. 

1737
01:19:16,040 --> 01:19:19,312
 Tapi di koran, mereka dengan santai mengabaikan ini 

1738
01:19:19,312 --> 01:19:20,770
 mengatakan itu memiliki hingga 2x overhead, 

1739
01:19:20,770 --> 01:19:24,870
 jadi tidak ada yang akan melakukan itu, tetapi Anda bisa melakukan itu. 

1740
01:19:24,870 --> 01:19:27,100
 Jadi pada dasarnya itulah cara kerja BROP. 

1741
01:19:27,100 --> 01:19:29,670
 Adapun soal pekerjaan rumah, pekerjaan rumah 

1742
01:19:29,670 --> 01:19:32,140
 pertanyaan agak halus, karena pertanyaan pekerjaan rumah mengatakan, 

1743
01:19:32,140 --> 01:19:36,610
 bagaimana jika Anda menggunakan hash waktu saat ini, kan? 

1744
01:19:36,610 --> 01:19:39,060
 Dapatkan waktu hari ketika Anda memulai ulang program. 

1745
01:19:39,060 --> 01:19:42,950
 Apakah itu cukup untuk mencegah jenis serangan ini? 

1746
01:19:42,950 --> 01:19:46,780
 Perhatikan bahwa, hashing tidak secara ajaib 

1747
01:19:46,780 --> 01:19:50,010
 memberikan Anda sedikit entropi jika masukan ke hash 

1748
01:19:50,010 --> 01:19:51,890
 mudah ditebak, benar. 

1749
01:19:51,890 --> 01:19:54,860
 Jika saya tahu bahwa Anda hanya akan memiliki satu atau dua hal, 

1750
01:19:54,860 --> 01:19:58,160
 tidak masalah jika saya memiliki beberapa hash jutih. 

1751
01:19:58,160 --> 01:19:58,930
 Tidak masalah. 

1752
01:19:58,930 --> 01:20:01,580
 Jadi saya bisa menebak salah satu dari dua nilai tersebut dan melihat apa yang ada. 

1753
01:20:01,580 --> 01:20:03,580
 Jadi hal yang perlu diperhatikan adalah bahwa mendapatkan waktu dalam sehari, 

1754
01:20:03,580 --> 01:20:06,110
 sebenarnya memiliki lebih sedikit entropi dari yang Anda kira. 

1755
01:20:06,110 --> 01:20:09,070
 Khususnya karena penyerang sebenarnya bisa 

1756
01:20:09,070 --> 01:20:12,690
 periksa jam berapa dia meluncurkan serangan, benar. 

1757
01:20:12,690 --> 01:20:15,150
 Jadi itu akan benar-benar menghapus sekelompok entropi 

1758
01:20:15,150 --> 01:20:17,170
 dari perhitungan itu, benar. 

1759
01:20:17,170 --> 01:20:18,750
 Jadi ada beberapa kehalusan di sana. 

1760
01:20:18,750 --> 01:20:21,860
 Apa server miring dalam hal jam atau klien 

1761
01:20:21,860 --> 01:20:22,900
 dan seterusnya dan seterusnya. 

1762
01:20:22,900 --> 01:20:26,600
 Singkat cerita, menggunakan nilai dasar yang bisa ditebak, 

1763
01:20:26,600 --> 01:20:28,830
 bahkan dengan hanya bisa ditebak dalam kisaran, 

1764
01:20:28,830 --> 01:20:30,661
 sangat berguna untuk penyerang, benar. 

1765
01:20:30,661 --> 01:20:32,035
 Khususnya karena attack-- 

1766
01:20:32,035 --> 01:20:35,680
 kita dapat mulai mengubah sekelompok server secara paralel 

1767
01:20:35,680 --> 01:20:37,960
 dan tahu bahwa mereka semua harus memilikinya 

1768
01:20:37,960 --> 01:20:39,320
 nilai yang hampir sama, benar. 

1769
01:20:39,320 --> 01:20:41,440
 Ini adalah urutan bit yang tinggi, benar. 

1770
01:20:41,440 --> 01:20:42,890
 Singkat cerita, jawabannya adalah 

1771
01:20:42,890 --> 01:20:47,730
 itu, secara harfiah lebih baik daripada tidak ada yang dapat diacak, 

1772
01:20:47,730 --> 01:20:50,390
 jika Anda menggunakan waktu, tetapi itu tidak benar-benar memberi Anda 

1773
01:20:50,390 --> 01:20:51,870
 keamanan sebanyak yang Anda pikirkan. 

1774
01:20:51,870 --> 01:20:53,953
 Dan pelajaran lainnya juga, itu hanya karena Anda 

1775
01:20:53,953 --> 01:20:55,640
 hash sesuatu yang benar, itu tidak 

1776
01:20:55,640 --> 01:20:59,052
 masalah jika Anda tidak benar-benar menggunakan hash itu dengan cara yang cerdas. 

1777
01:20:59,052 --> 01:21:00,036
 Anda punya pertanyaan? 

1778
01:21:00,036 --> 01:21:03,480
 AUDIENCE: Oh, masih ketika saya melakukan perhitungan bahwa beberapa 

1779
01:21:03,480 --> 01:21:09,604
 [TIDAK JELAS] sepertinya mungkin terjadi 

1780
01:21:09,604 --> 01:21:13,712
 bisa mendapatkan offset yang [tidak terdengar] 

1781
01:21:13,712 --> 01:21:17,616
 Anda [TIDAK JELAS] memulai proses 

1782
01:21:17,616 --> 01:21:19,249
 ke dalam seperti 48 milidetik? 

1783
01:21:19,249 --> 01:21:21,040
 PROFESOR: Ya dan mendapatkan waktu yang tepat 

1784
01:21:21,040 --> 01:21:22,780
 tergantung pada banyak hal yang berbeda, benar. 

1785
01:21:22,780 --> 01:21:24,000
 Tetapi Anda bisa memanfaatkan fakta itu 

1786
01:21:24,000 --> 01:21:26,166
 bahwa penyerang dapat membuka banyak koneksi 

1787
01:21:26,166 --> 01:21:27,640
 secara paralel, dan memanfaatkan fakta 

1788
01:21:27,640 --> 01:21:29,640
 bahwa bahkan jika tebakan awal sedikit, 

1789
01:21:29,640 --> 01:21:31,900
 Anda masih bisa meluncurkan beberapa tebakan tentang apa 

1790
01:21:31,900 --> 01:21:34,209
 harus nilai kenari yang sangat mirip, 

1791
01:21:34,209 --> 01:21:35,500
 dan melakukan serangan itu secara paralel. 

1792
01:21:35,500 --> 00:00:00,000
 Tapi kamu benar, ada waktu dan masalah yang rumit. 

